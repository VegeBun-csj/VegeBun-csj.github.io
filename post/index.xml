<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on This is a blog written by VegeBun-csj to record the tech</title><link>http://localhost:1313/post/</link><description>Recent content in Posts on This is a blog written by VegeBun-csj to record the tech</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 24 Dec 2020 19:58:03 +0800</lastBuildDate><atom:link href="http://localhost:1313/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode51 N皇后</title><link>http://localhost:1313/post/leetcode/%E5%9B%9E%E6%BA%AF%E6%B3%95/leetcode51-n%E7%9A%87%E5%90%8E/</link><pubDate>Thu, 24 Dec 2020 19:58:03 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E5%9B%9E%E6%BA%AF%E6%B3%95/leetcode51-n%E7%9A%87%E5%90%8E/</guid><description>题目描述 题目链接 思路 代码</description></item><item><title>Leetcode46 全排列</title><link>http://localhost:1313/post/leetcode/%E5%9B%9E%E6%BA%AF%E6%B3%95/leetcode46-%E5%85%A8%E6%8E%92%E5%88%97/</link><pubDate>Thu, 24 Dec 2020 19:57:52 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E5%9B%9E%E6%BA%AF%E6%B3%95/leetcode46-%E5%85%A8%E6%8E%92%E5%88%97/</guid><description>题目描述 题目链接 思路 代码</description></item><item><title>Leetcode814 二叉树剪枝</title><link>http://localhost:1313/post/leetcode/%E5%9B%9E%E6%BA%AF%E6%B3%95/leetcode814-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/</link><pubDate>Thu, 24 Dec 2020 19:56:23 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E5%9B%9E%E6%BA%AF%E6%B3%95/leetcode814-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/</guid><description>题目描述 给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。 返回移除了所有不包含 1 的子树的原二叉树。 ( 节点 X 的子树为 X 本身，以及所有</description></item><item><title>顶点覆盖</title><link>http://localhost:1313/post/%E5%9B%BE/%E9%A1%B6%E7%82%B9%E8%A6%86%E7%9B%96/</link><pubDate>Sun, 13 Dec 2020 16:13:22 +0800</pubDate><guid>http://localhost:1313/post/%E5%9B%BE/%E9%A1%B6%E7%82%B9%E8%A6%86%E7%9B%96/</guid><description>顶点覆盖</description></item><item><title>Leetcode208 实现Trie树</title><link>http://localhost:1313/post/leetcode/%E5%89%8D%E7%BC%80%E6%A0%91/leetcode208-%E5%AE%9E%E7%8E%B0trie%E6%A0%91/</link><pubDate>Fri, 11 Dec 2020 20:46:15 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E5%89%8D%E7%BC%80%E6%A0%91/leetcode208-%E5%AE%9E%E7%8E%B0trie%E6%A0%91/</guid><description>题目描述 实现一个 Trie (前缀树)，包含 insert, search, 和 startsWith 这三个操作。 示例: Trie trie = new Trie(); trie.insert(&amp;ldquo;apple&amp;rdquo;); trie.search(&amp;ldquo;apple&amp;rdquo;); // 返回 true trie.search(&amp;ldquo;app&amp;rdquo;); // 返回 false trie.startsWith(&amp;ldquo;app&amp;rdquo;); // 返回 true trie.insert(&amp;ldquo;app&amp;rdquo;); trie.search(&amp;ldquo;app&amp;rdquo;); // 返回 true 题目链接 https://leetcode-cn.com/problems/implement-trie-prefix-tree 思路 前缀树 根据前</description></item><item><title>Leetcode32 最长有效括号</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</link><pubDate>Tue, 08 Dec 2020 20:00:01 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode32-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</guid><description>题目描述 给定一个只包含 &amp;lsquo;(&amp;rsquo; 和 &amp;lsquo;)&amp;rsquo; 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 输入: &amp;ldquo;(()&amp;rdquo; 输出: 2 解释: 最长有效括号子串为 &amp;ldquo;()&amp;rdquo; 示例2 : 输入: &amp;ldquo;)()())&amp;rdquo; 输</description></item><item><title>Leetcode20 有效的括号</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link><pubDate>Tue, 08 Dec 2020 19:49:22 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid><description>题目描述 给定一个只包括 &amp;lsquo;('，')'，'{'，'}'，'['，']&amp;rsquo; 的字符串，判断字符串是否有效。 有效字符串需满足：</description></item><item><title>数据库的锁</title><link>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81/</link><pubDate>Mon, 07 Dec 2020 21:34:06 +0800</pubDate><guid>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E9%94%81/</guid><description>数据库的锁 乐观并发控制锁(Optimistic concurrency control) 。。。 悲观锁</description></item><item><title>闫式DP</title><link>http://localhost:1313/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%97%AB%E5%BC%8Fdp/</link><pubDate>Mon, 07 Dec 2020 21:27:35 +0800</pubDate><guid>http://localhost:1313/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E9%97%AB%E5%BC%8Fdp/</guid><description>DP（动态规划） 1.常用模型：背包 平时很多遇到的模型都是背包模型，只是换了一个背景 2.几种常用的模型：线性DP,区间DP。。。 动态规划问题没</description></item><item><title>01背包</title><link>http://localhost:1313/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E7%B3%BB%E5%88%97/01%E8%83%8C%E5%8C%85/</link><pubDate>Mon, 07 Dec 2020 21:26:15 +0800</pubDate><guid>http://localhost:1313/post/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/%E8%83%8C%E5%8C%85%E7%B3%BB%E5%88%97/01%E8%83%8C%E5%8C%85/</guid><description>题目描述 有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。 第 i 件物品的体积是 vi，价值是 wi。 求解将哪些物品装入背包，可使这些物品的总体</description></item><item><title>A Transactional Perspective on Execute Order Validate Blockchains——Sigmod2020</title><link>http://localhost:1313/post/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/sigmod/a-transactional-perspective-on-execute-order-validate-blockchainssigmod2020/</link><pubDate>Mon, 07 Dec 2020 11:46:45 +0800</pubDate><guid>http://localhost:1313/post/%E8%AE%BA%E6%96%87%E7%A0%94%E8%AF%BB/sigmod/a-transactional-perspective-on-execute-order-validate-blockchainssigmod2020/</guid><description>A Transactional Perspective on Execute-order-validate Blockchains(Sigmod2020) 作者开源了FabricSharp项目代码 https://github.com/ooibc88/FabricSharp Introduction 受数据库领域的乐观并发控制锁的启发，提出了一种对于增强EOV(execute-ord</description></item><item><title>Leetcode78 子集</title><link>http://localhost:1313/post/leetcode/%E4%BD%8D%E8%BF%90%E7%AE%97/leetcode78-%E5%AD%90%E9%9B%86/</link><pubDate>Sun, 06 Dec 2020 19:47:23 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E4%BD%8D%E8%BF%90%E7%AE%97/leetcode78-%E5%AD%90%E9%9B%86/</guid><description>题目描述 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。 **说明：**解集不能包含重复的子集。 示例: 输入: nums = [1,2,3] 输</description></item><item><title>Leetcode25 K个一组反转链表</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Sun, 06 Dec 2020 11:51:37 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode25-k%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>题目描述 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，</description></item><item><title>Leetcode92 反转链表II</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</link><pubDate>Sun, 06 Dec 2020 09:57:06 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode92-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8ii/</guid><description>题目描述 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 说明: 1 ≤ m ≤ n ≤ 链表长度。 示例: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 输出: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL 题目链接 https://leetcode-cn.com/problems/reverse-linked-list-ii 思路 一般而言</description></item><item><title>Leetcode239 滑动窗口最大值</title><link>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</link><pubDate>Mon, 30 Nov 2020 11:38:17 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC/</guid><description>在进入leetcode题目之前先来个Acwing的题目热个身：题目来自https://www.acwing.com/，由北大yxc大佬建的刷</description></item><item><title>Leetcode1052 爱生气的书店老板</title><link>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</link><pubDate>Sun, 29 Nov 2020 20:06:46 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode1052-%E7%88%B1%E7%94%9F%E6%B0%94%E7%9A%84%E4%B9%A6%E5%BA%97%E8%80%81%E6%9D%BF/</guid><description>题目描述 今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离</description></item><item><title>Leetcode876 链表的中间节点</title><link>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</link><pubDate>Sat, 28 Nov 2020 19:03:46 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode876-%E9%93%BE%E8%A1%A8%E7%9A%84%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9/</guid><description>题目描述 给定一个头结点为 head 的非空单链表，返回链表的中间结点。 如果有两个中间结点，则返回第二个中间结点。 题目链接 https://leetcode-cn.com/problems/middle-of-the-linked-list/ 思路 快慢指针 一个快指针，一个</description></item><item><title>Leetcode26 删除排序数组中的重复项</title><link>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link><pubDate>Fri, 27 Nov 2020 11:12:27 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid><description>题目描述 给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在 原</description></item><item><title>Leetcode34 在排序数组中查找元素的第一个和最后一个位置</title><link>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</link><pubDate>Thu, 26 Nov 2020 19:10:04 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</guid><description>题目描述 给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 你的算法时间复杂度必须</description></item><item><title>二分查找</title><link>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Thu, 26 Nov 2020 18:21:11 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description>二分法 对于二分法非常容易出问题的就是查找的边界问题 下面是两个常用的模板框架： 框架一 1 2 3 4 5 6 7 8 9 10 11 int l = 0; int r = nums.size() - 1; while (l &amp;lt;= r) { int mid =</description></item><item><title>Leetcode74 搜索二维矩阵</title><link>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</link><pubDate>Thu, 26 Nov 2020 11:29:54 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode74-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</guid><description>题目描述 编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： 每行中的整数从左到右按升序排列。 每行的第一个整数大于前</description></item><item><title>Leetcode35 搜索插入位置</title><link>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link><pubDate>Thu, 26 Nov 2020 09:19:10 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E5%8F%8C%E6%8C%87%E9%92%88/leetcode35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid><description>题目描述 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数</description></item><item><title>02 K-近邻算法(KNN)</title><link>http://localhost:1313/post/machining-learing/02-k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</link><pubDate>Wed, 25 Nov 2020 17:10:02 +0800</pubDate><guid>http://localhost:1313/post/machining-learing/02-k-%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95/</guid><description>K-近邻算法(KNN)</description></item><item><title>Leetcode30 串联所有单词的子串</title><link>http://localhost:1313/post/leetcode/hash%E8%A1%A8/leetcode30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</link><pubDate>Mon, 23 Nov 2020 17:59:20 +0800</pubDate><guid>http://localhost:1313/post/leetcode/hash%E8%A1%A8/leetcode30-%E4%B8%B2%E8%81%94%E6%89%80%E6%9C%89%E5%8D%95%E8%AF%8D%E7%9A%84%E5%AD%90%E4%B8%B2/</guid><description>题目描述 给定一个字符串 s 和一些长度相同的单词 words。找出 s 中恰好可以由 words 中所有单词串联形成的子串的起始位置。 注意子串要与 words 中的单词完全匹</description></item><item><title>Leetcode03 无重复字符的最长子串</title><link>http://localhost:1313/post/leetcode/hash%E8%A1%A8/leetcode03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link><pubDate>Mon, 23 Nov 2020 11:13:33 +0800</pubDate><guid>http://localhost:1313/post/leetcode/hash%E8%A1%A8/leetcode03-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid><description>题目描述 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 题目链接 https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/ 思路 hash表 + 双指针 hash表用来存放字符串s中的字符；设置</description></item><item><title>Leetcode347 前k个高频元素</title><link>http://localhost:1313/post/leetcode/hash%E8%A1%A8/leetcode347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</link><pubDate>Sat, 21 Nov 2020 10:08:15 +0800</pubDate><guid>http://localhost:1313/post/leetcode/hash%E8%A1%A8/leetcode347-%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0/</guid><description>题目描述 给定一个非空的整数数组，返回其中出现频率前 k 高的元素。 示例 1: 输入: nums = [1,1,1,2,2,3], k = 2 输出: [1,2] 示例 2: 输入: nums = [1], k = 1 输出: [1] 题目链接 https://leetcode-cn.com/problems/top-k-frequent-elements 思路</description></item><item><title>C++中stringstream用法</title><link>http://localhost:1313/post/c++/c++%E4%B8%ADstringstream%E7%94%A8%E6%B3%95/</link><pubDate>Thu, 19 Nov 2020 09:59:50 +0800</pubDate><guid>http://localhost:1313/post/c++/c++%E4%B8%ADstringstream%E7%94%A8%E6%B3%95/</guid><description/></item><item><title>Leetcode297 二叉树的序列化和反序列化</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link><pubDate>Thu, 19 Nov 2020 09:17:53 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid><description>题目描述 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一</description></item><item><title>Leetcode114 二叉树展开为链表</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 17 Nov 2020 21:53:48 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid><description>题目描述 给定一个二叉树，原地将它展开为一个单链表。 例如，给定二叉树 题目链接 https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/ 思路 二叉树的题目都可以使用递归来做，对于递归，我们并不需要深入到</description></item><item><title>Leetcode106 从中序和后序遍历构造二叉树</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Tue, 17 Nov 2020 21:48:38 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>题目描述 根据一棵树的中序遍历与后序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 题目链接 https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal 思路 思路</description></item><item><title>Leetcode105 从前序和中序遍历构造二叉树</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Tue, 17 Nov 2020 21:48:20 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>题目描述 根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 题目链接 https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal 思路 首先</description></item><item><title>Leetcode654 最大二叉树</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Tue, 17 Nov 2020 21:32:45 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>题目描述 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分</description></item><item><title>01机器学习基础</title><link>http://localhost:1313/post/machining-learing/01%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</link><pubDate>Mon, 16 Nov 2020 19:37:33 +0800</pubDate><guid>http://localhost:1313/post/machining-learing/01%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80/</guid><description>最近想对机器学习入个门，毕竟咱也不能落伍，虽然之前也耳濡目染😄不过还是系统学一下比较好，毕竟里面的一些经典算法模型对于一个研究生来讲不得不知</description></item><item><title>BFS遍历模板</title><link>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/bfs%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</link><pubDate>Mon, 16 Nov 2020 14:38:28 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/bfs%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</guid><description>BFS模板 BFS又称宽度优先遍历，类似于树中的层次遍历，是一种从上至下，一层一层进行的遍历，通常采用队列来实现 基本框架 1 2 3 4 5 6 7 8 9 10 11</description></item><item><title>Leetcode513 找树左下角的值</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode-513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</link><pubDate>Mon, 16 Nov 2020 11:42:28 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode-513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</guid><description>题目描述 给定一个二叉树，在树的最后一行找到最左边的值。（这里说的是最后一层的最左边的值，并不是直观上的最左下角的节点哦） 题目链接 https://leetcode-cn.com/problems/find-bottom-left-tree-value/ 思路一(B</description></item><item><title>递归的写法以及注意点</title><link>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/%E9%80%92%E5%BD%92%E7%9A%84%E5%86%99%E6%B3%95/</link><pubDate>Sun, 15 Nov 2020 15:52:47 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/%E9%80%92%E5%BD%92%E7%9A%84%E5%86%99%E6%B3%95/</guid><description>所有的树的问题，都可以转化为递归来解决 递归的步骤：（产品经理法） 确定递归的边界 确定递归要干的事情 递归的返回值 递归的一个非常重要的点就是：不去</description></item><item><title>Leetcode129 求根到叶子节点数字之和</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</link><pubDate>Sun, 15 Nov 2020 15:30:47 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</guid><description>题目描述 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&amp;gt;2-&amp;gt;3 代表数字 123。 计</description></item><item><title>二叉树的遍历系列_4种</title><link>http://localhost:1313/post/leetcode/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%B3%BB%E5%88%97_4%E7%A7%8D/</link><pubDate>Sat, 14 Nov 2020 21:00:34 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%B3%BB%E5%88%97_4%E7%A7%8D/</guid><description>题目描述 对二叉树进行前中后层序遍历，分别递归与非递归遍历 题目链接 leetcode 144 https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ leetcode94 https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ leetcode145 https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ 102 https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 思路 递归遍历 三种遍历的唯一区别就是对根节点的操作和递归操作</description></item><item><title>Leetcode226 翻转二叉树_二叉树的镜像</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link><pubDate>Sat, 14 Nov 2020 20:58:21 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid><description>题目描述 翻转一棵二叉树。 题目链接 https://leetcode-cn.com/problems/invert-binary-tree/ 思路 首先可以看到，翻转后的二叉树就是： 以根节点为基础交换两棵左右子树 交换完成后再对左右子树进行同样的操作（</description></item><item><title>Leetcode100 相同的树</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link><pubDate>Sat, 14 Nov 2020 16:06:45 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid><description>题目描述 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 题目链接 https://leetcode-cn.com/problems/same-tree/ 思路 题目</description></item><item><title>Leetcode104 二叉树的最大深度</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link><pubDate>Fri, 13 Nov 2020 14:58:27 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid><description>题目描述 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给</description></item><item><title>Leetcode01 两数之和</title><link>http://localhost:1313/post/leetcode/hash%E8%A1%A8/leetcode01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link><pubDate>Fri, 13 Nov 2020 14:36:06 +0800</pubDate><guid>http://localhost:1313/post/leetcode/hash%E8%A1%A8/leetcode01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid><description>题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对</description></item><item><title>Leetcode206 反转链表</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Thu, 12 Nov 2020 14:58:23 +1600</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>题目描述 反转一个单链表。 示例: 1 2 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 题目链接 https://leetcode-cn.com/problems/reverse-linked-list/ 思路一 迭代：使用双指针，同样为了操作的一致性，需要创建一个虚拟节点dummpy，</description></item><item><title>Leetcode142 环形链表II</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link><pubDate>Wed, 11 Nov 2020 15:08:34 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid><description>题目链接 https://leetcode-cn.com/problems/linked-list-cycle-ii/ 思路 使用双指针，一个快指针，一个慢指针，需要进行数学推导证明，记住这个规律即可：设置一个快指针，一个慢指针，都一开始从链表head</description></item><item><title>Leetcode160 相交链表</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link><pubDate>Wed, 11 Nov 2020 15:05:15 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid><description>题目链接 https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 思路 寻找相交的点。本题的解法非常巧妙，采用的双指针，即链表A一个指针ptr1进行遍历，链表B一个指针ptr2进行遍历； 两者一开始都</description></item><item><title>Leetcode109 有序链表转换为二叉搜索树</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Wed, 11 Nov 2020 15:03:56 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>题目链接 https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/ 思路 将一个有序的链表转换为二叉搜索树，并且还要求，这个二叉搜索树为平衡二叉树，所以为了保持平衡，选取链表的中间节点为树的根节点，然</description></item><item><title>Leetcode61 旋转链表</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Wed, 11 Nov 2020 15:01:50 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>题目描述 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2 输出: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL 解释: 向右旋转 1 步: 5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL 向右旋转 2</description></item><item><title>Leetcode24 两两交换链表中的节点</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link><pubDate>Wed, 11 Nov 2020 14:58:23 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid><description>题目描述 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 例子： 输入：</description></item><item><title>Leetcode768 最多能完成排序的块II</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode768-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97ii/</link><pubDate>Tue, 10 Nov 2020 21:44:32 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode768-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97ii/</guid><description>题目链接 https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/ 思路 题目要求最大的分块数目，本身题目隐含的意思就是块内是可以是无序的，但是每个块整体上是递增的，也就是说每个块中的最大值是递增的，</description></item><item><title>Leetcode232 用栈实现队列</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link><pubDate>Tue, 10 Nov 2020 21:44:13 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid><description>题目链接 https://leetcode-cn.com/problems/shortest-distance-to-a-character/ 解题思路 左右两边进行遍历，分别找字符串中每个字符距离左边C最近的距离和距离右边C最近的距离，然后取两者中的较小者 代码 1 2 3 4 5 6 7</description></item><item><title>Leetcode394 字符串解码</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link><pubDate>Tue, 10 Nov 2020 21:43:48 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid><description>题目链接 https://leetcode-cn.com/problems/decode-string/ 思路 本题是括号匹配的问题，对于数字和字符都分别用一个栈来存放，当遇到[时，就将数字和字符串分别入栈，遇到]时就将数字和字符串出栈，</description></item><item><title>Leetcode1381 设计一个支持增量操作的栈</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode1381-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/</link><pubDate>Tue, 10 Nov 2020 21:43:33 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode1381-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/</guid><description>题目链接 https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/ 思路： 采用数组进行模拟 代码(cpp) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class CustomStack { public: int top; vector&amp;lt;int&amp;gt; simu_stack; //用数</description></item><item><title>Leetcode821 字符最短距离</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode821-%E5%AD%97%E7%AC%A6%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</link><pubDate>Tue, 10 Nov 2020 21:43:08 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode821-%E5%AD%97%E7%AC%A6%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</guid><description>题目链接 https://leetcode-cn.com/problems/shortest-distance-to-a-character/ 思路 左右两边进行遍历，分别找字符串中每个字符距离左边C最近的距离和距离右边C最近的距离，然后取两者中的较小者 代码 1 2 3 4 5 6 7 8 9</description></item><item><title>Leetcode66 加一</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode66-%E5%8A%A0%E4%B8%80/</link><pubDate>Tue, 10 Nov 2020 21:42:43 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode66-%E5%8A%A0%E4%B8%80/</guid><description>题目链接 https://leetcode-cn.com/problems/plus-one/ 题目描述： 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数</description></item><item><title>Fabric中的账本数据存储</title><link>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%B8%AD%E7%9A%84%E8%B4%A6%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</link><pubDate>Sun, 18 Oct 2020 21:26:31 +0800</pubDate><guid>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%B8%AD%E7%9A%84%E8%B4%A6%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</guid><description>Fabric账本数据的存储 Fabric账本数据存储模块提供了文件系统与键值型数据库用于存储账本数据，并被统一封装为Peer节点的账本对象（ k</description></item><item><title>Fabric中的读写集</title><link>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E9%9B%86/</link><pubDate>Sun, 18 Oct 2020 21:25:21 +0800</pubDate><guid>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E9%9B%86/</guid><description>Fabric中的读写集 在背书节点模拟执行交易期间，都会为每笔交易生成一个读写集。 读集(readset)包含了在模拟执行期间读取到的键的列表和</description></item><item><title>链码常见的API</title><link>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/%E9%93%BE%E7%A0%81%E5%B8%B8%E8%A7%81%E7%9A%84api/</link><pubDate>Sun, 18 Oct 2020 21:24:00 +0800</pubDate><guid>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/%E9%93%BE%E7%A0%81%E5%B8%B8%E8%A7%81%E7%9A%84api/</guid><description>levelDB和CouchDB都支持的API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //键的写入 PutState(key string, value []byte) error //单个键的查询 GetState(key string) ([]byte, error) //键的范围查询(左</description></item><item><title>Fabric启用CouchDB作为状态数据库</title><link>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/fabric%E5%90%AF%E7%94%A8couchdb%E4%BD%9C%E4%B8%BA%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Sun, 18 Oct 2020 21:22:31 +0800</pubDate><guid>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/fabric%E5%90%AF%E7%94%A8couchdb%E4%BD%9C%E4%B8%BA%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>Fabric中启用CouchDB 使用CouchDB的注意点 当chaincode的数据模型被构建为Json格式的时候，可以使用CouchDB，</description></item><item><title>CouchDB的基本语法</title><link>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E5%BA%93/couchdb%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link><pubDate>Sun, 11 Oct 2020 21:16:52 +0800</pubDate><guid>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E5%BA%93/couchdb%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid><description>CouchDB基本语法 CouchDB的查询语法是json格式的，在其中可以通过特定的字段构建查询的逻辑，它的selector语法和Mongo</description></item><item><title>Fabric交易流程的详细分析</title><link>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%BA%A4%E6%98%93%E6%B5%81%E7%A8%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</link><pubDate>Sun, 11 Oct 2020 21:14:08 +0800</pubDate><guid>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%BA%A4%E6%98%93%E6%B5%81%E7%A8%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</guid><description>Fabric交易流程的详细分析 总体来讲，一个交易流程分为3个阶段：交易的模拟执行、交易打包生成区块、账本的更新 交易流程图： 第一阶段： 客户端创</description></item><item><title>背书节点和提交节点</title><link>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E8%83%8C%E4%B9%A6%E8%8A%82%E7%82%B9%E5%92%8C%E6%8F%90%E4%BA%A4%E8%8A%82%E7%82%B9/</link><pubDate>Sat, 10 Oct 2020 21:11:44 +0800</pubDate><guid>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E8%83%8C%E4%B9%A6%E8%8A%82%E7%82%B9%E5%92%8C%E6%8F%90%E4%BA%A4%E8%8A%82%E7%82%B9/</guid><description>背书节点（Endorser peer） 主要是对请求服务的签名提案消息 启动链码容器 模拟执行链码 签名背书 客户端提交到账本的普通交易都需要经过背书节</description></item><item><title>动态添加组织</title><link>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E7%BB%84%E7%BB%87/</link><pubDate>Mon, 05 Oct 2020 09:03:17 +0800</pubDate><guid>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E7%BB%84%E7%BB%87/</guid><description>动态添加组织——CLI端 官方推荐将Cli容器与Org3cli容器的日志等级设置为DEBUG级别(但是我实际搭建也没有换，也没啥问题，可能是为</description></item><item><title>动态添加peer节点</title><link>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0peer%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 05 Oct 2020 08:53:09 +0800</pubDate><guid>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0peer%E8%8A%82%E7%82%B9/</guid><description>大致流程 生成节点证书文件(依然是用过crypto-config.yaml文件) 启动新节点的docker容器 节点加入通道 节点安装链码 节点端执行</description></item><item><title>求逆序对(归排变种)</title><link>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E5%BD%92%E6%8E%92%E5%8F%98%E7%A7%8D/</link><pubDate>Sun, 30 Aug 2020 15:43:52 +0800</pubDate><guid>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E5%BD%92%E6%8E%92%E5%8F%98%E7%A7%8D/</guid><description>逆序对，简单的说就是一个序列中，前面的数的数值比后面的数的数值大，那么这两个数就可以构成一个逆序对。 比如说 1 4 7 2 1 这个序列中，{4，2}{</description></item><item><title>快速选择(快排变种)--求第k个数</title><link>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E5%BF%AB%E6%8E%92%E5%8F%98%E7%A7%8D-%E6%B1%82%E7%AC%ACk%E4%B8%AA%E6%95%B0/</link><pubDate>Sun, 30 Aug 2020 14:38:56 +0800</pubDate><guid>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E5%BF%AB%E6%8E%92%E5%8F%98%E7%A7%8D-%E6%B1%82%E7%AC%ACk%E4%B8%AA%E6%95%B0/</guid><description>对于求一个序列的第k个数，首先想到的就是将序列进行排序，然后输出第k-1的下标即可，但是排序的算法平均时间复杂度最优的也是O(nlogn)，</description></item><item><title>排序(快排与归并)</title><link>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%BF%AB%E6%8E%92%E4%B8%8E%E5%BD%92%E5%B9%B6/</link><pubDate>Sun, 30 Aug 2020 10:15:11 +0800</pubDate><guid>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%BF%AB%E6%8E%92%E4%B8%8E%E5%BD%92%E5%B9%B6/</guid><description>对于基础算法可以形成模板来进行记忆，主要在于算法的思想和熟练度！！！ 快速排序 基本思想 找分界点，随便找，一般是a[l]，a[r]，a[l+r&amp;</description></item><item><title>IPFS-js的简单使用</title><link>http://localhost:1313/post/ipfs/ipfs-js%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 29 Aug 2020 14:51:33 +0800</pubDate><guid>http://localhost:1313/post/ipfs/ipfs-js%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid><description/></item><item><title>fabric事件的监听使用</title><link>http://localhost:1313/post/fabricnodesdk/%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%91%E5%90%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 29 Aug 2020 14:34:22 +0800</pubDate><guid>http://localhost:1313/post/fabricnodesdk/%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%91%E5%90%AC%E4%BD%BF%E7%94%A8/</guid><description>使用fabric-network如何监听事件 本教程描述了使用fabricnetwork模块监听网络发出的事件的不同方法。 概览有三种事件类型可</description></item><item><title>交易invoke的使用</title><link>http://localhost:1313/post/fabricnodesdk/%E4%BA%A4%E6%98%93invoke%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 29 Aug 2020 14:25:47 +0800</pubDate><guid>http://localhost:1313/post/fabricnodesdk/%E4%BA%A4%E6%98%93invoke%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>Fabric 1.4.x的新版高级API(Fabrci-NetWork模块)的使用 新版api引入了fabric-network模块，在原来的fabric</description></item><item><title>链码的访问控制(cid库)</title><link>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/cid%E9%93%BE%E7%A0%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%BA%93/</link><pubDate>Sat, 29 Aug 2020 13:27:15 +0800</pubDate><guid>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/cid%E9%93%BE%E7%A0%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%BA%93/</guid><description>Client Identity Chaincode Library（客户端标识链代码库） The client identity chaincode library enables you to write chaincode which makes access control decisions based on the identity of the client (i.e. the invoker of the chaincode). In particular, you may make access control decisions based on either or both of the following associated with the client: 客</description></item><item><title>ccp文件的设置</title><link>http://localhost:1313/post/fabricnodesdk/ccp-connection-file%E7%9A%84%E8%AE%BE%E7%BD%AE/</link><pubDate>Sat, 29 Aug 2020 13:03:02 +0800</pubDate><guid>http://localhost:1313/post/fabricnodesdk/ccp-connection-file%E7%9A%84%E8%AE%BE%E7%BD%AE/</guid><description>1.实验环境时，我们使用cli容器来进行链码的部署，实例化，以及进行简单的交易操作，但是在Fabric进行开发时，为了避免命令行的繁琐行，采</description></item><item><title>fabric1.4.x 网络部署的一些坑</title><link>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/fabric1.4.x%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</link><pubDate>Fri, 28 Aug 2020 17:18:13 +0800</pubDate><guid>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/fabric1.4.x%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</guid><description>下面的搭建主要是基于fabric1.4.x出现错误 1.创建通道出现错误(注意如果出现重复创建通道建议去清理网络) 1 config update for existing channel did not pass initial checks: implicit policy evaluation</description></item><item><title>以太坊Ghost协议(5)</title><link>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8Aghost%E5%8D%8F%E8%AE%AE5/</link><pubDate>Mon, 24 Aug 2020 21:52:57 +0800</pubDate><guid>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8Aghost%E5%8D%8F%E8%AE%AE5/</guid><description>在以太坊中，出块的时间相对于BTC来说是非常短暂的，只有十几秒，但是出块时间越短，出现的短暂性分叉也就越多，这就会对部分节点，尤其是个体挖矿</description></item><item><title>以太坊交易树和收据树(4)</title><link>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%914/</link><pubDate>Mon, 24 Aug 2020 21:51:47 +0800</pubDate><guid>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%914/</guid><description>交易树与状态树 状态树 交易树 收据树 (把系统中的所有状态都记录进去，不管账户是否与当前区块中的相关交易关联的账户是什么关系) 区块产生时会生成(类</description></item><item><title>以太坊状态树(3)</title><link>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%913/</link><pubDate>Mon, 24 Aug 2020 21:50:16 +0800</pubDate><guid>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%913/</guid><description>在Ethereum中，账户的状态是以键值对&amp;lt;key,value&amp;gt;的形式保存的，账户地址为key，账户的状态就是value，即&amp;l</description></item><item><title>以太坊账户(2)</title><link>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B72/</link><pubDate>Mon, 24 Aug 2020 21:46:36 +0800</pubDate><guid>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B72/</guid><description>背景 比特币中采用的是基于交易的账本，这种模式下，系统中并没有显式地记录账户中有多少钱 ，只能根据UTXO中的信息来推算。这种方式的隐私性较好，</description></item><item><title>以太坊概述(1)</title><link>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E8%BF%B01/</link><pubDate>Mon, 24 Aug 2020 21:40:38 +0800</pubDate><guid>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E8%BF%B01/</guid><description>以太坊被称为区块链2.0 创世人是V神，属于公有链的代表，和BTC的不同是，以太坊引入了智能合约，可以进行复杂的业务设计，不仅仅局限于解决pa</description></item><item><title>Git的基本使用</title><link>http://localhost:1313/post/git/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 23 Aug 2020 20:57:28 +0800</pubDate><guid>http://localhost:1313/post/git/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>Git的基本使用 新项目提交至github 1 2 3 4 5 6 7 8 9 10 git init //创建本地仓库 git add . //提交全部 git commit -m &amp;#34;提交时的注释，尽量写，方便</description></item></channel></rss>
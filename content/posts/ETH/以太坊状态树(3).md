---
title: "以太坊状态树(3)"
date: 2020-08-24T21:50:16+08:00
tags:
- 区块链
Categories:
- 以太坊
---

在Ethereum中，账户的状态是以键值对<key,value>的形式保存的，账户地址为key，账户的状态就是value，即<addr,state>，所以对于这种存储结构，很容易想到的就是hash_table来进行存储。

#### 如何用hash_table来进行Merkle proof呢

（1）一种方法就是将hash_table中的value组织成一个Merkle tree,然后将root hash 保存在block header中，但是这种方法的问题在于，每次发布一个交易产生状态变化时，又需要重新组建一个新的Merkle tree，这样带来的代价太大，所以用这种方式提供Merkle proof不可行
注；BTC中构建Merkle tree只有一次，就是在区块生成的时候构建的，一旦构建就无法篡改，它是不会变化的，只构建一次，代表交易顺序的共识

##### Merkle Tree的作用：

- 提供Merkle proof（全节点提供部分分支给轻节点）
- 维护账本的一致性（保证区块中的交易顺序和交易的共识）



（2）另一种提供方法是，不使用hash_table，直接使用Merkle tree，把账户的状态存储在叶节点中，但是这种方式查找和更新的效率并不高，另外一个问题就是这个状态的Merkle tree是否需要进行排序？

账户的状态是保存在叶节点中的，如果不规定账户在叶节点中出现的顺序，那么构造出的Merkle tree就是不唯一的，但是状态是网络上每个节点都需要保存，各个节点按照自己保存的账户顺序构建Merkle tree ，导致Merkle root hash不同，他们就无法对账户状态达成共识，所以，如果采用直接构建Merkle tree来组织账户和状态的存储，那么对于树中的账户必须排序！！！

（BTC中，要证明一笔交易包含在区块中是不用排序的，但是要证明一笔交易不在一个区块中是需要对交易进行排序的，也就是sorted Merkle tree）

BTC中的Merkle树是不需要排序的，因为，最终的Merkle树的构造方式是由获得记账权（打包交易出块）的节点决定的，也就是说，在没出块之前，所有的节点都可以有自己根据交易构造Merkle tree的顺序，每个节点可能都不一样，过程中都是“百家争鸣”，但是最终的交易构造Merkle tree的顺序是由最终出块，并被追加到区块链上的哪个节点决定的，它出了块代表了最终的Merkle tree中的交易构造顺序。那么能否也用同样的方式，不对状态树中的账户进行排序，也采用由出块的节点进行选择呢？不行，因为这就导致在每次发布交易的时候都需要发布更新一次Merkle tree，ETH中是13秒一个块，这样大量造成重复的发布，代价很大（因为状态树是存储的网络中的所有账户状态的，相比于一个块中的交易而言，相差好几个数量级！！！，多次重复发布，代价太大），所以从这一点也验证了不排序不行！！！

好的，那么如果用排序的Merkle tree行不行呢？同样的也有一种问题就是，如果由新账户怎么办？如果新增的账户在中间的叶子节点部分，就会导致树的变化太大，造成代价太大的问题。

```注释
关于区块中交易顺序（交易顺序实际上就是一种共识）：
BTC和ETH中都是以获得记账权的节点为标准的，他们发布的区块中的交易顺序是什么，最后大家共识的交易顺序就是什么？
fabric中是order节点进行排序的。
```



ETH采用的是MPT树。

未完待续----------------------------
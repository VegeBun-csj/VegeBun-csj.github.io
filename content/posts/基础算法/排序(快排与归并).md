---
title: "排序(快排与归并)"
date: 2020-08-30T10:15:11+08:00
tags:
- 排序
- C++
- 算法基础
- 双指针
Categories:
- 基础算法
---

> ##### 对于基础算法可以形成模板来进行记忆，主要在于算法的思想和熟练度！！！

### 快速排序

- > 基本思想

  1. 找分界点，随便找，一般是a[l]，a[r]，a[l+r>>1]
  2. 划分区间（划分的规则就是使得分界点的左区间都是<=分界点，分界点的右区间都是>=分界点）
  3. 递归左右区间

- > 题目

  给定你一个长度为n的整数数列。

  请你使用快速排序对这个数列按照从小到大进行排序。

  并将排好序的数列按顺序输出。

  #### 输入格式

  输入共两行，第一行包含整数 n。

  第二行包含 n 个整数（所有整数均在1~10^9范围内），表示整个数列。

  #### 输出格式

  输出共一行，包含 n 个整数，表示排好序的数列。

  #### 数据范围

  1≤n≤100000

  **输入样例：**

  ```
  5
  3 1 2 4 5
  ```

  **输出样例：**

  ```
  1 2 3 4 5
  ```

- > 代码

  ```c++
  #include<iostream>
  using namespace std;
  
  const int maxn = 1000000;
  int n;
  int q[maxn];
  
  void quick_sort(int q[],int l,int r){
      if(l>=r) return;
      int i = l-1,j = r+1, x = q[(l+r)>>1];	//1.选定分界点(此处是区间中点)
      while(i < j){							//2.区间划分
          while(q[++i]<x);
          while(q[--j]>x);
          if(i<j) swap(q[i],q[j]);
      }
  
      quick_sort(q,l,j);						//3.递归处理左右边界
      quick_sort(q,j+1,r);
  }
  
  int main(){
      cin>>n;
      for(int i = 0;i < n;i ++) cin>>q[i];
      quick_sort(q,0,n-1);
      for(int i = 0 ;i < n;i ++) cout<<q[i];
      return 0;
  }
  ```

  > **注意：在一开始i = l - 1,j = r + 1，是因为下面while循环的时候是先移动i和j，然后再将对应位置的值与x比较的**



### 归并排序

- > 思想：

  1. 找分界点（归并里面的分界点就是区间的中点）
  2. 递归处理左右区间
  3. 归并（两个有序的合并为一个有序的）

- > 题目

  给定你一个长度为n的整数数列。

  请你使用归并排序对这个数列按照从小到大进行排序。

  并将排好序的数列按顺序输出。

  #### 输入格式

  输入共两行，第一行包含整数 n。

  第二行包含 n 个整数（所有整数均在1~10^9范围内），表示整个数列。

  #### 输出格式

  输出共一行，包含 n 个整数，表示排好序的数列。

  #### 数据范围

  1≤n≤1000001

  #### 输入样例：

  ```
  5
  3 1 2 4 5
  ```

  #### 输出样例：

  ```
  1 2 3 4 5
  ```

- 代码

  ```c++
  #include<iostream>
  using namespace std;
  
  int n;
  const int maxn = 1000000;
  int q[maxn],temp[maxn];
  
  void merge_sort(int q[],int l,int r){
      if(l >= r) return;
      int mid = (l+r)>>1;
      merge_sort(q,l,mid);
      merge_sort(q,mid+1,r);
      //i,j分别代表两个区间的起始位置下标，k为暂存数组下标
      int i = l,j = mid +1,k = 0;
      //合并两个有序区间（起始时都是一个元素，都是有序的，然后递归层层往上走）
      while(i<=mid&&j<=r){
          if(q[i]<=q[j]) temp[k++] = q[i++];
          else temp[k++] = q[j++];
      }
      //如果其中任意一个序列还有剩余，就将剩下的部分逐个加入临时数组
      while(i<=mid) temp[k++] = q[i++];
      while(j<=r) temp[k++] = q[j++];
      
      //将临时数组中的元素赋值给原数组
      for(int i = l,j =0 ;i<=r;i++,j++) q[i] = temp[j];
  }
  
  
  int main(){
      scanf("%d",&n);
      for(int i = 0;i < n;i ++) scanf("%d",&q[i]);
      merge_sort(q,0,n-1);
      for(int i = 0;i < n;i ++) printf("%d ",q[i]);
      return 0;
  }
  ```

  > 归并排序中需要有一个临时数组来暂存归并的序列，首先是经过递归处理，直到每个区间都是1个元素的时候，默认是有序的，然后归并为序列为2的序列，再层层向上归并，最终成为一个有序序列



总结：

1. 快排和归并都是采用的 **分治** 的思想，将大问题拆分为一个个相似的小问题，再逐个解决，最后将这些小问题的结果汇总出来形成最终问题的解。但是快排和归并的分治规则不一样：快排是按照一个数x(x的左边区间都小于这个数，右边区间都大于这个数)来进行分的；归并排序是按照区间的中点进行划分,即 l + r >>1
2. 快排是找分界点，先划分区间，再进行递归区间；归并排序是先进行递归区间，再进行归并。因为快排的区间划分需要找到分界点，而分界点是通过首位指针移动来实现的；但是归并的分界点一开始就很明确，就是区间的中点，所以先递归，到最底层之后，再两两序列归并。
3. 都是采用的双指针算法。快排是采用的首尾指针，而归并是相当于两个数组的头指针进行移动(因为可以把左右区间理解为两个数组)
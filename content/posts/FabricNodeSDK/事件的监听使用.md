---
title: "fabric事件的监听使用"
date: 2020-08-29T14:34:22+08:00
tags:
- 区块链
- golang
- javascript
Categories:
- Hyperledger Fabric--NodeSDK开发
---

## **使用fabric-network如何监听事件**

本教程描述了使用fabricnetwork模块监听网络发出的事件的不同方法。

- 概览有三种事件类型可以订阅


1. 合约事件（contract event）——那些由chaincode开发人员在事务中显式发出的事件
2. 事务(提交)事件(transaction event)——在调用后提交事务时自动发出的事件
3. 块事件（Block event）——当一个块被提交时自动发出的事件侦听这些事件允许应用程序在不直接调用事务的情况下进行响应。这在监视网络分析等用例中非常理想

- 用法


每个侦听器类型至少接受一个参数，即事件回调。这是接收到事件时调用的函数。 给定的回调函数应该是一个promise，这意味着回调可以执行异步任务而不会有丢失事件的风险

> 可选项[module:fabric-network.Network~EventListenerOptions](https://hyperledger.github.io/fabric-sdk-node/release-1.4/module-fabric-network.Network.html#~EventListenerOptions).

注意:监听器(listener)将连接到事件集线器（event hub），并请求**默认接收未过滤的事件**。要接收过滤的事件，请设置 *EventListenerOptions.filtered: true*

- 命名


所有事件监听器(包括使用事务ID的commiteventlistener)在网络级别上必须有**唯一的名称**

## Contract events

```javascript
const gateway = new Gateway();
await gateway.connect(connectionProfile, gatewayOptions);
const network = await gateway.getNetwork('mychannel');
const contract = network.getContract('my-contract');

/**
 * @param {String} listenerName the name of the event listener
 * @param {String} eventName the name of the event being listened to
 * @param {Function} callback the callback function with signature (error, event, blockNumber, transactionId, status)
 * @param {module:fabric-network.Network~EventListenerOptions} options
**/
const listener = await contract.addContractListener('my-contract-listener', 'sale', (err, event, blockNumber, transactionId, status) => {
    if (err) {
        console.error(err);
        return;
    }
    console.log(`Block Number: ${blockNumber} Transaction ID: ${transactionId} Status: ${status}`);
})

//注意，不需要指定事件中心event hub，因为EventHubSelectionStrategy将自动选择它。
```

## Block event

```javascript
const gateway = new Gateway();
await gateway.connect(connectionProfile, gatewayOptions);
const network = await gateway.getNetwork('mychannel');

/**
 * @param {String} listenerName the name of the event listener
 * @param {Function} callback the callback function with signature (error, blockNumber, transactionId, status)
 * @param {module:fabric-network.Network~EventListenerOptions} options
**/
const listener = await network.addBlockListener('my-block-listener', (error, block) => {
    if (err) {
        console.error(err);
        return;
    }
    console.log(`Block: ${block}`);
});

//在侦听块事件时，指定是否需要过滤或未过滤事件非常重要，因为这将确定哪个事件中心与请求兼容。
```

## Commit events

```javascript
//注意:侦听器侦听器名称是transactionId。<一串随机的字符串>
/*
订阅事务提交事件有两种方法。
1.使用模块:fabric-network.Network  
*/

const gateway = new Gateway();
await gateway.connect(connectionProfile, gatewayOptions);
const network = await gateway.getNetwork('mychannel');
const contract = network.getContract('my-contract');

const transaction = contract.newTransaction('sell');
/**
 * @param {String} transactionId the transaction ID
 * @param {Function} callback the callback function with signature (error, transactionId, status, blockNumber)
 * @param {Object} options
**/

//这里使用network的方法
const listener = await network.addCommitListener(transaction.getTransactionID().getTransactionID(), (err, transactionId, status, blockNumber) => {
    if (err) {
        console.error(err);
        return;
    }
    console.log(`Transaction ID: ${transactionId} Status: ${status} Block number: ${blockNumber}`);
});




/*
2.直接使用：fabric-network.Transaction。这种方式直接将需要指定希望侦听的事务ID抽象出来。
*/

const gateway = new Gateway();
await gateway.connect(connectionProfile, gatewayOptions);
const network = await gateway.getNetwork('mychannel');
const contract = network.getContract('my-contract');

const transaction = contract.newTransaction('sell');
/**
 * @param {String} transactionId the transaction ID
 * @param {Function} callback the callback function with signature (error, transactionId, status, blockNumber)
 * @param {Object} options
**/

//这里使用transaction的方法
const listener = await transaction.addCommitListener((err, transactionId, status, blockNumber) => {
    if (err) {
        console.error(err);
        return;
    }
    console.log(`Transaction ID: ${transactionId} Status: ${status} Block number: ${blockNumber}`);
});

```

**Network.addCommitListener**和**contract.addCommitListener**有一个可选的**eventHub**参数。设置后，侦听器将只侦听该**eventhub**，并且在发生意外断开连接时，它将尝试并重新连接，而**不使用EventHubSelectionStrategy**。



#### 合约事件(Contract event)的使用比较频繁，在链码中相应的方法中添加相关的事件，使用如下方法

```go
	tx_id := APIstub.GetTxID();
	eventpayload := " this transactionId is" + tx_id+"and this contract has been operated" ;
	err := APIstub.SetEvent("changeCar_Event",[]byte(eventpayload));
	if (err != nil) {
		return shim.Error(fmt.Sprintf("Failed to emit event"))
   }
```

注意上面的写法，其中就是调用了stub的SetEvent方法， 其中传入**两个参数**，第一个参数就是该事件的名（自定义，这个名字就是sdk进行addContractListener的时候会用到唯一的事件名），第二个参数就是[]]byte类型的event的payload

payload是自定义格式的，可以是json反序列化后的字符串，也可以是一条语句，看你自定义的事件输出格式，到时候这个payload在sdk调用完链码之后会输出的，例如如果上面这个链码的方法被调用，那么在调用结束的时候，就会输出：

```go
this transactionId is 交易id and this contract has been operated
```

其他的事件也可以使用，看自己的需求了，使用事件可以节省很多查询的操作。
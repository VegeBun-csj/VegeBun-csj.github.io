---
title: "快速选择(快排变种)--求第k个数"
date: 2020-08-30T14:38:56+08:00
tags:
- 排序
- C++
- 算法基础
- 双指针
Categories:
- 基础算法
---

对于求一个序列的第k个数，首先想到的就是将序列进行排序，然后输出第k-1的下标即可，但是排序的算法平均时间复杂度最优的也是O(nlogn)，诸如快排。有没有更高效的O(n)的复杂度的算法就可以得出第k个数呢?答案是肯定的！！

#### 快速选择算法——快排的变种算法，求第K个数，时间复杂度为O(n).

> 那为什么能够用这种方式来求呢，其实是跟快排的排序特点有关，个人觉得是快排每次进行一轮排序都会确定一个区间的分界点，这个分界点是它排序的最终位置，所以通过确定这个分界点是第几个元素，从而可以直到我们要找的第k个数是在分界点的左边区间还是右边区间，选择其中的一个区间进行递归即可，从而避免“无脑”地对左右区间进行递归，最终减少时间复杂度

- #### 题目

  给定一个长度为n的整数数列，以及一个整数k，请用快速选择算法求出数列的第k小的数是多少。

  #### 输入格式

  第一行包含两个整数 n 和 k。

  第二行包含 n 个整数（所有整数均在1~10^9范围内），表示整数数列。

  #### 输出格式

  输出一个整数，表示数列的第k小数。

  #### 数据范围

  1≤n≤100000
  1≤k≤n

  #### 输入样例：

  ```
  5 3
  2 4 1 5 3
  ```

  #### 输出样例：

  ```
  3
  ```

- #### 代码

  ```c++
  #include<iostream>
  using namespace std;
  
  const int maxn = 1000000;
  int n,k;
  int q[maxn];
  
  int quick_select(int q[],int l,int r,int k){
      if(l >= r) return q[l];
      int i = l-1, j = r + 1,x = q[l];
      while(i < j){
          while(q[++i]<x);
          while(q[--j]>x);
          if(i < j) swap(q[i],q[j]);
      }
      //当跳出循环时，j就是分界点，由此就可以知道下标为j的数是第 j - l + 1个数，即左区间的个数
      int s = j - l + 1;  
      if(k <= s) quick_select(q,l,j,k);	//如果k是小于等于这个左区间的个数，就递归左区间
      else quick_select(q,j+1,r,k-s);		//如果k是大于这个左区间的个数，就递归右区间
  }
  
  int main(){
      ios::sync_with_stdio(false);
      cin>>n>>k;
      for(int i = 0;i < n; i++) cin>>q[i];
      cout<<quick_select(q,0,n-1,k);
      return 0;
      
  }
  ```

  > 注意：递归右区间的时候，第k个数此时在右区间就是第k - s个数

总结：

- 相比较快排，快速选择就是在快排的基础上增加了对递归的限制条件而已，这样就较少了递归的次数
- 时间复杂度：第一趟寻找分界点时，左右指针移动了n次，第二趟寻找时，就会在一半的区间内进行移动，即n/2次，一次下去就是n/4 ..........这样算下来就是（n + n/2 + n/4 + n/ 8 + ....） = n (1 + 1/2 + 1/4 + ....) <= 2n.所以，复杂度就是O(N)。
---
title: "求逆序对(归排变种)"
date: 2020-08-30T15:43:52+08:00
tags:
- 排序
- C++
- 算法基础
- 双指针
Categories:
- 基础算法
---

逆序对，简单的说就是一个序列中，前面的数的数值比后面的数的数值大，那么这两个数就可以构成一个逆序对。

比如说

> 1 4 7 2 1 

这个序列中，{4，2}{4，1}{7，2}{7，1}就是逆序对。那么如何求一个序列中的逆序对的个数呢？可以使用归并排序，在归排的过程中统计逆序对的个数。

> **思想**：在归并排序中，我们是通过中间点分出区间，然后对左右区间进行递归，最后在进行归并。好，明白了这个过程下面就好办了。求逆序对的关键就是在归并之前进行操作，因为我们进行归并的前提条件是**归并两个有序的序列为一个有序的序列**，前提是两个序列有序，那么也就是说**如果一个序列a中某个数i大于另一个序列b中的某个数j，那么a序列中i后面的所有的数都是大于b序列中的数j的，那么这些数(包括i)就都可以和j构成逆序对。**所以我们只要计算出分界点左右区间中构成的所有的逆序对的数量即可（其中包括左区间的所有逆序对数，右区间的所有逆序对数，还有左右区间各拿出一个数构成的逆序对数）

- #### 题目：

  给定一个长度为n的整数数列，请你计算数列中的逆序对的数量。

  逆序对的定义如下：对于数列的第 i 个和第 j 个元素，如果满足 i < j 且 a[i] > a[j]，则其为一个逆序对；否则不是。

  #### 输入格式

  第一行包含整数n，表示数列的长度。

  第二行包含 n 个整数，表示整个数列。

  #### 输出格式

  输出一个整数，表示逆序对的个数。

  #### 数据范围

  1≤n≤1000001≤n≤100000

  #### 输入样例：

  ```
  6
  2 3 4 5 6 1
  ```

  #### 输出样例：

  ```
  5
  ```

- #### 代码

  ```c++
  #include<iostream>
  using namespace std;
  typedef long long LL;
  const int maxn = 100010;
  int n;
  int q[maxn],temp[maxn];
  
  LL merge_sort(int q[],int l,int r){
      if(l>=r) return 0;
      int mid = (l+r) >> 1;
  	//左右区间的逆序对总数
      LL res = merge_sort(q,l,mid)+merge_sort(q,mid+1,r);
  
      int i = l,j = mid + 1,k = 0;
      while(i<=mid&&j<=r){
          if(q[i]<=q[j]) temp[k++] = q[i++];
          else {
              temp[k++] = q[j++];
              //只要q[i] > q[j],左区间的i以及后面的所有的数都是大于q[j]的，都构成逆序对
              res += mid - i + 1; 
          }
      }
  
      while(i<=mid) temp[k++] = q[i++];
      while(j<=r) temp[k++] = q[j++];
  
      for(int i = l,j = 0;i <=r;i++,j++) q[i] = temp[j];
      return res;
  }
  
  int main(){
      ios::sync_with_stdio(false);
      cin>>n;
      for(int i = 0;i < n;i ++) cin>>q[i];
  
      cout<<merge_sort(q,0,n-1);
      return 0;
  }
  
  ```

  
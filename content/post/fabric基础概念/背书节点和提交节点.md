---
title: "背书节点和提交节点"
date: 2020-10-10T21:11:44+08:00
tags:
- 区块链
Categories:
- Hyperledger Fabric--基本概念
---

# 背书节点（Endorser peer）

主要是对请求服务的签名提案消息

- 启动链码容器
- 模拟执行链码
- 签名背书

客户端提交到账本的普通交易都需要经过背书节点的签名，并在收集到足够多的签名之后才能将 

多个`签名提案消息(signedProposal类型)、模拟执行结果、背书信息`(提案响应消息)

打包成`签名交易消息`(Envelope类型)，发送给Orderer节点

背书节点提供了`ProcessProposal`服务接口用来处理客户端的`签名提案消息`（SignedProposal类型），**用户链码容器**是由客户端通过`ProcessProposal`接口提交链码实例化请求，并在背书节点上通过LSCC系统链码间接的启动链码容器，与背书节点之间建立Grpc连接进行通信的。

> 注意：链码容器对象不保存任何本地数据，并且不绑定任何具体的通道链结构，所有同一个节点的不同通道，可以使用相同的链码规范名称的容器。

链码容器请求peer节点访问账本数据时，peer节点的Handle对象会查找指定链上的指定交易的交易上下文对象，利用该对象封装的交易模拟器访问账本数据，并将模拟执行结果暂存在交易模拟器当中，等待交易验证之后更新账本（注意交易有可能被标记为无效的交易）

.....

......

........源码分析





# 记账节点(Committer Peer)

Committer记账节点负责验证交易与提交账本，包括公有数据（即区块数据，包含公共数据与隐私数据哈希值）与隐私数据。 Committer记账节点在提交账本之前需要**验证交易数据的有效性**，如交易**消息格式的正确性**、签名合法性等，并调用**VSCC**( Validation System Chaincode，验证系统链码）**验证消息的合法性以及指定背书策略的有效性**。接着，验证并准备模拟执行结果读写集，执行**MVCC**( Multi- Version Concurrency Control）**多版本并发控制检查，用于检查读写冲突并标记交易的有效性**。最后，**提交所有区块数据到区块数据文件**以及所有隐私数据到隐私数据库，**建立索引信息并保存到区块索引数据库**，更新有效交易的公有数据（包含公共数据、隐私数据哈希值）与隐私数据到状态数据库，将经过 Endorser背书的**有效交易数据同步到历史数据库**，同时清理缓存隐私数据的 transient隐私数据库。

 Committer记账节点的功能模块（或称为Committer功能模块）包括交易验证模块（或称为交易验证器）与账本提交模块（或称为账本提交器）
 （1）**交易验证器**（ Validator接口）：定义了 Validate( block* common. Block）方法，用于**验证区块 block中交易数据的合法性，包括交易格式的合法性、背书策略的有效性（VSCC）**等；
 （2）**账本提交器**（ Committer接口）：定义了 Commit Withpvtdata( blockandpvtdata+ -ledge
 Blockandpvtdata）方法，**执行MVCC检查，基于状态数据检査模拟执行结果中的读写冲突，标记其中的无效交易，再提交区块与隐私数据对象 blockandpvtdata到账本中**。







### 交易验证器的两个功能：

> #### （1）验证交易格式的合法性

​				.......源码分析（主要是验证交易中的一些参数是否正确还有其他。。。。

​					....................................................

> #### （2）VSCC验证背书策略（三种方法来验证）

​				VSCC的**Invoke()**方法用于验证是否符合背书策略：

​						检查背书信息的有效性(是否使用了**有效的证书**进行了签名)

​						是否存在符合要求的背书数量(是否由**足够的背书**节点进行了背书)

​						是否符合预期的背书节点(即**指定的组织角色**进行了**背书**)

​				VSCC的 **Evaluate( signatures）**方法验证证书的有效性

>  Invoke方法调用 utils. Getlransaction(payl.Data)函数，从交易的消息负载对象的payl.Data中解析出交易对象tx( Transaction类型），循环遍历该交易包含的交易动作tx. Actions( Transactionaction类型）。接着，调用util. Getchaincodeactionpayload(act.Payload）函数，解析其链码动作消息负载cap( Chaincodeactionpayload类型），再调用vsccdeduplicateldentity( cap）方法去掉重复的背书实体信息，并创建过滤后的签名背书实体信息集合 signatureset([] *commor. Signeddata类型）。该对象封装了每个签名背书信息的被签名原始数据、签名身份实体、签名信息等。
>
>  最后， Invoke()方法调用 policy. Evaluate( signatures）方法以验证指定背书策略的有效性。该方法先调用 deduplicate( signatureset,p. deserializer）方法（ common/ cauthdsl/policy. go),解析并剔除 signature Set集合中重复的签名身份实体信息。接着，执行 evaluator()方法即上面编译的 compiled策略验证方法，调用 Satisfiesprincipal()方法，以检查消息中包含的签名身份实体集合，是否满足指定背书策略中 Msprincipal结构对象描述的实体类型要求。如果通过了上述背书策略的验证，则调用 utils. Get Chaincodeheaderextension(payl. Header）函数，解析提取消息头部的扩展项 hdrExt。最后，检査链码名称，如果是“lscc”系统链码，则继续调用vscc. Validatelsccinvocationo方法，针对LSCC链码调用执行特殊的验证流程。

​					VSCC构造策略验证方法**compile()**，它可以根据指定的背书策略，构造对应的策略验证方法,，验证是否由**足够的背书**

> Fabric基于签名策略的 Signaturepolicy结构对象支持两种背书策略类型：
>
> - 多个角色的签名组合策略 Signaturepolicy Noutof_类型
>
>   所有的组合签名背书策略都可以转换为Noutof_策略，通过验证的子策略数量 verified是否满足背书策略要求的个数，即verified大于等于N，并返回验证结果。
>
> - 单个角色的签名策略 Signaturepolicy Signedby类型
>
>   只要存在一个通过签名背书验证的签名数据，就返回验证通过的结果（true）。只有当所有签名数据都没有通过验证时，才返回验证未通过的结果（ false）

​						VSCC的**Satisfiesprincipal()**验证签名**身份实体满足背书策略要求**

> Satisfiesprincipal(）方法可用于检查当前消息中的签名身份实体集合，验证其是否满足指定背书策略中 Msprincipal结构对象描述的实体类型要求。其中， Msprincipal 3结构对象代表MSP组件中一类具有特定身份的实体集合，包括3种类型
>
> - Mspprincipal_ROLE类型、
>
> - Mspprincipal_ IDENTITY类型
>
> - Mspprincipal_ ORGANIZATION UNIT类型。



.....................还有其他的源码未分析..............................................



### 账本提交器的两个功能：

（1）MVCC多版本并发控制

（2）提交数据到账本



### 总结：Committer节点的作用就是

- 验证交易格式的合法性
- 验证背书策略(VSCC)（**有效的、足够的、特定组织角色**的背书）
- MVCC多版本并发控制检查(读写集)，标记交易的有效性
- 提交区块数据（公共数据与隐私数据哈希值）到**区块文件**中，更新**区块索引数据库**，保存隐私数据到**隐私数据库**，同步有效交易的数据到**状态数据库**，提交经过Endorser背书签名的**有效交易数据到历史数据库**。

> #### 前两点是由交易验证器做的，后两点是由账本提交器做的！！！！！	
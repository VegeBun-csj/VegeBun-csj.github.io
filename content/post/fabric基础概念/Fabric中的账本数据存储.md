---
title: "Fabric中的账本数据存储"
date: 2020-10-18T21:26:31+08:00
tags:
- 区块链
Categories:
- Hyperledger Fabric--基本概念
---

# Fabric账本数据的存储

>  Fabric账本数据存储模块提供了**文件系统**与**键值型数据库**用于存储账本数据，并被统一封装为Peer节点的账本对象（ kedger类型）进行管理，包括**账本数据存储对象**（管理区块数据文件、隐私数据库与区块索引数据库）、**状态数据库**、**历史数据库**、**transient隐私数据库**等。 
>
>  Fabric中经常采用提供者模式（ ProviderPattern）来分离接口的定义与具体实现，Peer节点的**账本提供者（ kedger. Provider类型）**包含的多种数据库提供者负责创建上述数据库，采用 Leveldb类型或 COUCHDB类型数据库作为底层的键值型数据库，同时采用文件系统保存区块数据。其中， idstore账本数据库由Peer节点的账本提供者负责管理。
>
>  注意：对于账本**区块文件**上的区块数据， Fabric**只支持查询与添加记录**，不支持删除与修改已有记录。

### 下面来详细说明Fabric中的几种数据库的存储：

账本目录结构：

![账本目录结构](https://cdn.jsdelivr.net/gh/VegeBun-csj/Images/peer_ledger_structure.png)

> （版本不同这个目录有点差异，但是大体的目录是一致的，包括状态数据库如果启用CouchDB的话是没有StateLevelDB的）

- 账本数据: 实际的区块数据存储
- 区块索引: 快速查询区块/交易
- 历史数据: 跟踪键的历史
- 账本编号:快速查询存在哪些账本
- 状态数据: 最新的世界状态数据

每个Peer节点会维护四个DB和多个不同的账本区块(chains)，分别为:

![各个账本之间的关系](https://cdn.jsdelivr.net/gh/VegeBun-csj/Images/ledger_relation.png)

- 区块文件系统(chains):存储区块文件

  区块数据以**文件块**的形式进行存储的，文件命名方式"blockfile_"加上六位数编号 。
  现阶段的实现中，每个文件块大小为`64M`，这是**硬编码**到代码中的，并不是以可配置的形式暴露给使用者的。如果想要更改这个数值就要修改源代码并重新编译peer节点。所以一个账本的最大容量就是64M * 区块编号的最大值。区块编号的最大值可设置的范围是(0~999999)。

  > 在上面的账本目录结构中，chains/chains下面就是区块文件系统，是以不同通道名区分命名的，上图中只有一个mychannel

- 区块索引库(BlockIndex):存储Block索引（默认为levelDB）

  区块索引的设计目的：**快速定位区块**。
  具体实现流程：将**查询条件**与**区块位置**建立映射关系。
  查询条件可以为：区块编号、区块hash、交易id。
  对应的索引值为：区块文件编号(blockfile_xxxxxxx)+偏移量+区块数据长度。即，从哪个区块文件开始读->从该文件的哪里开始读->读多长的数据。

  > 在账本的目录结构中，chains/index就是区块的索引数据库

- 历史数据库(HistoryDB): 存储的是智能合约中写入的key的历史记录的索引地址（默认为levelDB）

  > 可选的数据库

  历史状态索引是一个**可选**模块。是否启用，完全是看智能合约中是否有一个**查询历史**的需求。

  历史状态索引模块中只是记录了某个键值对在某个区块中的某笔交易中被改变了。而且**只是单纯地记录了发生了改变，并不记录是如何被改变的**。

  > 因为存储的是key的历史索引，所以查询历史数据的时候，就是从这个数据库中获取key的历史索引地址，然后根据这个历史索引地址去对应的区块文件中读取对应的交易的value
  >
  > 这里要强调一点：历史数据库中并不存储历史的数据交易，而是存储的相关键的历史索引
  >
  > 在上面的账本目录结构中就是`historyleveldb`

- 账本索引库(IdStore)：存储ChainID(即当前节点所包含的channel的信息)

  > 在上面的目录结构中就是`ledgerProvider`

- 状态数据库(StateDB): 存储world state

  - 世界状态可以**提升**智能合约的**执行效率**，快速获取**账本最新值**而不必根据交易日志从头开始计算。
    如果每次都要回到存储区块链数据的文件块中读取数据，效率是极低的。这时，世界状态就像一个**缓存**。每次只需要去这里读取最新的数据，并且随着区块链进行**实时更新**。

  - 世界状态是所有交易日志的快照，可以随时重构的。每次peer节点启动的时候，都会自动去检查自己的世界状态是否跟当前区块链保持一致。如果不一致，就会自动根据区块链为基准调整自己的世界状态。**协调一致**后，才代表peer节点启动成功。
    现阶段的Fabric提供`levelDB`和`CouchDB`作为世界状态的**存储引擎**。除了levelDB和CouchDB在功能性上表现出的不同之外，levelDB跟peer节点处于同一个进程中，而CouchDB作为一个第三方数据库自起进程。既然是第三方数据库，那么就需要通过网络通信来进行数据的交互，也增加了运维的负担。

  > 装填数据库的存储引擎是可以**动态修改**的。如果第一次peer节点使用的是levelDB，那么完全可以在第二次启动的时候改为CouchDB。



此处没有用到隐私数据库，所以暂未讨论，后面用到再说。。。。。。。

> 在最后的区块被提交到peer节点账本之后，会提交所有的区块数据（公共数据）到**区块数据文件**中，保存所有的私有数据(隐私数据)到**隐私数据库(leveldb)**中，建立区块索引信息到**区块索引数据库**，同步**有效交易数据**(公共数据，隐私数据读写集，隐私数据读写集的hash值)到**状态数据库**，提交经过Endorser背书签名的**有效交易数据到历史数据库**。



参考自：

> https://www.pianshen.com/article/4847298290/
>
> https://www.cnblogs.com/cnblogs-wangzhipeng/p/9044622.html
>
> https://blog.csdn.net/u010986776/article/details/84839487
>



---



kedger. Provider类型对象作为Per节点的账本提供者，实现了 Peerledgerprovider接口，封装了账本底层的各类数据库提供者，用于创建对应的数据库实例。Peer节点启动时调用 ledgermgm. Initialize(0→ kvledger. Newprovider(0函数，创建Peer节点的账本提供者（ kedger. Provider类型）

NewProvider()函数依次创建 idstore数据库、账本数据存储对象提供者、状态数据库提供者、历史数据库提供者等，并在最后调用 recoverunderconstruction Ledger方法，检查并恢复未完成构造的Peer节点账本对象(崩溃故障等原因）

![image-20201010111536046](https://cdn.jsdelivr.net/gh/VegeBun-csj/Images/image-20201010111536046.png)
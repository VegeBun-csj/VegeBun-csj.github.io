---
title: "Fabric中的读写集"
date: 2020-10-18T21:25:21+08:00
tags:
- 区块链
Categories:
- Hyperledger Fabric--基本概念
---

### Fabric中的读写集

在背书节点模拟执行交易期间，都会为每笔交易生成一个读写集。

`读集(readset)`包含了在模拟执行期间读取到的键的列表和它们上次被提交时的版本号，

`写集(writeset)`包含了键的列表(可能于读集中的键重复)和交易即将对它们写的值

> 如果一个交易写操作是删除一个键(并不是真的移除这个键)，会在这个键上加一个`delete`标记

`如果交易对同一个键进行了多次的写入，那只会以最后一次被写入时为准`。另外，即使在事务读取结果发出之前更新了键值，也会返回事务读取已提交状态的值

> 键的版本只会记录在读集中，但是写集中只包含键的列表和交易设置的最新值

有各种方法来实现版本管理，版本控制最简单的就是为一个给定的键生成一个`不重复的`标识。例如，可以通过`递增的数字`来实现版本管理。

在目前的实现中，Fabric采用的是用`区块高度`(当交易被提交的时候区块)作为当前所有交易修该过的键的版本号。在这种方案中，`交易的高度`是用一个元组表示的（txNumber是该交易在区块中的高度），这种方式比之前使用单调递增的数字来管理版本有很多优势

即 **版本号 = 区块高度 + 交易ID**

> 这里要说明一些，读集中键得版本号是和区块高度有关，而并非单调增的数字，网上很多文章都描述的时候都是以官方这个示例说的，并没有说名这一点，给了我很多误解！！！所以最靠谱的还是官文！！！

下面是一个模拟执行得交易所涉及得读写集，为了简单起见，使用递增得数字来表示版本号。

```xml
<TxReadWriteSet>
  <NsReadWriteSet name="chaincode1">
    <read-set>
      <read key="K1", version="1">
      <read key="K2", version="1">
    </read-set>
    <write-set>
      <write key="K1", value="V1">
      <write key="K3", value="V2">
      <write key="K4", isDelete="true">
    </write-set>
  </NsReadWriteSet>
<TxReadWriteSet>
```

如果交易在模拟执行期间进行了`键的范围查询`，范围查询的结果也会被放如读写集中作为一个查询信息`query-info`



### 交易验证和通过读写集更新世界状态

committer节点在最后的验证阶段，通过读写集中的

- `读集`对交易进行**验证**（验证只涉及**读集中键的版本**不涉及写集）
- `写集`来**更新**相关键的**版本和值**

在验证阶段，如果一个交易中的读集的版本和当前世界状态中的读集的版本一致，就被认为是合法的（假设在这个区块中的所有交易都是合法的），如果读写集中包含了一个或者更多的`query-info`，那么还会进行额外的附加验证

这个额外的附加验证可以确保在这个范围查询所得到的结果集中，没有键被插入/删除/更新，换句话讲，在验证并更新账本期间，如果我们重复执行范围查询，应该能得到和模拟执行期间一样的结果，这就能确保，如果一个交易在提交期间出现了`幻读`，这笔交易就会被标记为无效。

> 注意：这种幻读的保护，只对`GetStateByRange`这个键的范围查询有效，并没有对其他查询进行实现。其他的查询是有幻读风险的，并且应该在交易中只进行读取操作，不包含交易调用

如果一个交易通过了验证检查，committer节点就会使用读集对世界状态进行更新，在更新的阶段，遍历写集中的每个键并将它们在世界状态中的值更新为写集中的值，另外，键的版本，也会更改为最新的版本

下面举一个例子：`(键,版本,值)`

> 假设下面的交易是以T1到T5的相对排序排列的，可以在同一个区块/不同的区块中

```xml
World state: (k1,1,v1), (k2,1,v2), (k3,1,v3), (k4,1,v4), (k5,1,v5)
T1 -> Write(k1, v1'), Write(k2, v2')
T2 -> Read(k1), Write(k3, v3')
T3 -> Write(k2, v2'')
T4 -> Write(k2, v2'''), read(k2)
T5 -> Write(k6, v6'), read(k5)
```

分析：

1. T1会通过验证，因为它没有任何的读操作(再次注意，验证的通过与否只与这个交易的过程的读集有关， 没有读操作的交易一律都是通过验证的！！！)，所以第一笔交易结束后，世界状态就会更新为`(k1,2,v1),(k2,2,v2)`
2. T2会验证失败，因为它对`k1`进行了读(读本身没问题，主要是这个k1在T1中的版本已经被修改了，T2读取的k1的版本为1，而此时k1的版本已经更新为2,会与当前的世界状态版本不一致)
3. T3会通过验证，因为没有读操作；更新世界状态为`(k2,3,v2)`
4. T4会验证失败，因为有读操作(T4读取的k2的版本为1，但是此时的k2的版本已经变为了3，和当前状态数据库中的版本已经不一致了)
5. T5会通过验证，虽然它有读操作，但是它读取的键在之前并没有交易进行修改过，所以它读取的k6的版本号和此时状态数据库中的版本号一致，所以可以通过

> 目前还不支持一个交易中包含多个读写集

看到这里，其实也有一些感想，Fabric中的交易真的像极了人生，即使你当前的交易和别人的交易都是合法的，但是就是出场顺序的问题，就因为人家的交易被排序节点排序的时候放在你的交易的前面，而你俩都是对同一个键感兴趣，最终因为人家先来，被抢了先，你最后结果被人给拒绝了！！是因为你不够优秀么？？？其实你俩一样哈哈哈，就是人家运气好，你就得重头再来，这笔交易就无效咯。

> 源自官文：
>
> https://hyperledger-fabric.readthedocs.io/en/release-1.4/readwrite.html



### 补充部分：

- 版本号，主要是记录交易中读得数据得版本，并不是简单得在一个数据更新后自增1，而是以`区块高度+交易ID`作为版本，这样同时系统并不需使用一个额外得字段来保存版本号，只需要使用已经存在得数据进行处理进性版本管理

  > 在其他区块链中，有个**区块确认高度**的概念。表示在这个高度之前区块链数据是被整个区块量网络认可的，不可再更改的。这样做的目的是为了**防止分叉**。
  > 在Fabric中没有分叉的概念，所以对应的"确认高度"就是**上一个区块**，即上一个区块就被认定为已提交的状态。

- 如果在非拜占庭的环境下进行交易，背书节点模拟执行结果，生成读写集合，至于这个读写集能不能提交到账本中进行更新(状态数据库)就要看orderer节点怎么排序了， 如果运气不好，有一个交易在你之前更新了键的数据和版本，那不好意思，你提交的交易也会被标记为无效的，所以，出场顺序很重要哦

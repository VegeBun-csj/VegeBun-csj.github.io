<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>This is a blog written by VegeBun-csj to record the tech</title><link>http://localhost:1313/</link><description>Recent content on This is a blog written by VegeBun-csj to record the tech</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 16 Nov 2020 14:38:28 +0800</lastBuildDate><atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml"/><item><title>BFS遍历模板</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/bfs%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</link><pubDate>Mon, 16 Nov 2020 14:38:28 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/bfs%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</guid><description>BFS模板 BFS又称宽度优先遍历，在树的遍历中又称为层次遍历，是一种从上至下，一层一层进行的遍历，通常采用队列来实现 基本框架 1 2 3 4 5 6 7 8</description></item><item><title>Leetcode513 找树左下角的值</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode-513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</link><pubDate>Mon, 16 Nov 2020 11:42:28 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode-513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</guid><description>题目描述 给定一个二叉树，在树的最后一行找到最左边的值。 题目链接 https://leetcode-cn.com/problems/find-bottom-left-tree-value/ 思路一(BFS) BFS：通常我们写的BFS是从上往下，从左往右遍历，这样遍历</description></item><item><title>Leetcode513 找树左下角的值</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</link><pubDate>Mon, 16 Nov 2020 11:42:28 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode513-%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</guid><description/></item><item><title>递归的写法以及注意点</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/%E9%80%92%E5%BD%92%E7%9A%84%E5%86%99%E6%B3%95/</link><pubDate>Sun, 15 Nov 2020 15:52:47 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/%E9%80%92%E5%BD%92%E7%9A%84%E5%86%99%E6%B3%95/</guid><description>所有的树的问题，都可以转化为递归来解决 递归的步骤：（产品经理法） 确定递归的边界 确定递归要干的事情 递归的返回值 递归的一个非常重要的点就是：不去</description></item><item><title>Leetcode129 求根到叶子节点数字之和</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</link><pubDate>Sun, 15 Nov 2020 15:30:47 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</guid><description>题目描述 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&amp;gt;2-&amp;gt;3 代表数字 123。 计</description></item><item><title>Leetcode226 二叉树的遍历_3种</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86_3%E7%A7%8D/</link><pubDate>Sat, 14 Nov 2020 21:00:34 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86_3%E7%A7%8D/</guid><description>题目描述 对二叉树进行前中后序遍历 题目链接 https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ 思路 递归遍历，三种遍历的唯一区别就是对根节点的操作和递归操作左右子树的顺序不一样， 代码 前序遍历</description></item><item><title>Leetcode226 翻转二叉树_二叉树的镜像</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link><pubDate>Sat, 14 Nov 2020 20:58:21 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid><description>题目描述 翻转一棵二叉树。 题目链接 https://leetcode-cn.com/problems/invert-binary-tree/ 思路 首先可以看到，翻转后的二叉树就是： 以根节点为基础交换两棵左右子树 交换完成后再对左右子树进行同样的操作（</description></item><item><title>Leetcode100 相同的树</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link><pubDate>Sat, 14 Nov 2020 16:06:45 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid><description>题目描述 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 题目链接 https://leetcode-cn.com/problems/same-tree/ 思路 题目</description></item><item><title>Leetcode104 二叉树的最大深度</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link><pubDate>Fri, 13 Nov 2020 14:58:27 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid><description>题目描述 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给</description></item><item><title>Leetcode01 两数之和</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link><pubDate>Fri, 13 Nov 2020 14:36:06 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode01-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid><description>题目描述 给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对</description></item><item><title>Leetcode206 反转链表</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Thu, 12 Nov 2020 14:58:23 +1600</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>题目描述 反转一个单链表。 示例: 1 2 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 题目链接 https://leetcode-cn.com/problems/reverse-linked-list/ 思路一 迭代：使用双指针，同样为了操作的一致性，需要创建一个虚拟节点dummpy，</description></item><item><title>Leetcode142 环形链表II</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</link><pubDate>Wed, 11 Nov 2020 15:08:34 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8ii/</guid><description>题目链接 https://leetcode-cn.com/problems/linked-list-cycle-ii/ 思路 使用双指针，一个快指针，一个慢指针，需要进行数学推导证明，记住这个规律即可：设置一个快指针，一个慢指针，都一开始从链表head</description></item><item><title>Leetcode160 相交链表</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link><pubDate>Wed, 11 Nov 2020 15:05:15 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid><description>题目链接 https://leetcode-cn.com/problems/intersection-of-two-linked-lists/ 思路 寻找相交的点。本题的解法非常巧妙，采用的双指针，即链表A一个指针ptr1进行遍历，链表B一个指针ptr2进行遍历； 两者一开始都</description></item><item><title>Leetcode109 有序链表转换为二叉搜索树</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link><pubDate>Wed, 11 Nov 2020 15:03:56 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode109-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid><description>题目链接 https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/ 思路 将一个有序的链表转换为二叉搜索树，并且还要求，这个二叉搜索树为平衡二叉树，所以为了保持平衡，选取链表的中间节点为树的根节点，然</description></item><item><title>Leetcode61 旋转链表</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</link><pubDate>Wed, 11 Nov 2020 15:01:50 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode61-%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid><description>题目描述 给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 示例 1: 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2 输出: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL 解释: 向右旋转 1 步: 5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;NULL 向右旋转 2</description></item><item><title>Leetcode24 两两交换链表中的节点</title><link>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link><pubDate>Wed, 11 Nov 2020 14:58:23 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%93%BE%E8%A1%A8/leetcode24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid><description>题目描述 给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 例子： 输入：</description></item><item><title>Leetcode768 最多能完成排序的块II</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode768-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97ii/</link><pubDate>Tue, 10 Nov 2020 21:44:32 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode768-%E6%9C%80%E5%A4%9A%E8%83%BD%E5%AE%8C%E6%88%90%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9D%97ii/</guid><description>题目链接 https://leetcode-cn.com/problems/max-chunks-to-make-sorted-ii/ 思路 题目要求最大的分块数目，本身题目隐含的意思就是块内是可以是无序的，但是每个块整体上是递增的，也就是说每个块中的最大值是递增的，</description></item><item><title>Leetcode232 用栈实现队列</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</link><pubDate>Tue, 10 Nov 2020 21:44:13 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</guid><description>题目链接 https://leetcode-cn.com/problems/shortest-distance-to-a-character/ 解题思路 左右两边进行遍历，分别找字符串中每个字符距离左边C最近的距离和距离右边C最近的距离，然后取两者中的较小者 代码 1 2 3 4 5 6 7</description></item><item><title>Leetcode394 字符串解码</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</link><pubDate>Tue, 10 Nov 2020 21:43:48 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode394-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%A7%A3%E7%A0%81/</guid><description>题目链接 https://leetcode-cn.com/problems/decode-string/ 思路 本题是括号匹配的问题，对于数字和字符都分别用一个栈来存放，当遇到[时，就将数字和字符串分别入栈，遇到]时就将数字和字符串出栈，</description></item><item><title>Leetcode1381 设计一个支持增量操作的栈</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode1381-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/</link><pubDate>Tue, 10 Nov 2020 21:43:33 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode1381-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E6%94%AF%E6%8C%81%E5%A2%9E%E9%87%8F%E6%93%8D%E4%BD%9C%E7%9A%84%E6%A0%88/</guid><description>题目链接 https://leetcode-cn.com/problems/design-a-stack-with-increment-operation/ 思路： 采用数组进行模拟 代码(cpp) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class CustomStack { public: int top; vector&amp;lt;int&amp;gt; simu_stack; //用数</description></item><item><title>Leetcode821 字符最短距离</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode821-%E5%AD%97%E7%AC%A6%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</link><pubDate>Tue, 10 Nov 2020 21:43:08 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode821-%E5%AD%97%E7%AC%A6%E6%9C%80%E7%9F%AD%E8%B7%9D%E7%A6%BB/</guid><description>题目链接 https://leetcode-cn.com/problems/shortest-distance-to-a-character/ 思路 左右两边进行遍历，分别找字符串中每个字符距离左边C最近的距离和距离右边C最近的距离，然后取两者中的较小者 代码 1 2 3 4 5 6 7 8 9</description></item><item><title>Leetcode66 加一</title><link>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode66-%E5%8A%A0%E4%B8%80/</link><pubDate>Tue, 10 Nov 2020 21:42:43 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%95%B0%E7%BB%84%E6%A0%88%E9%98%9F%E5%88%97/leetcode66-%E5%8A%A0%E4%B8%80/</guid><description>题目链接 https://leetcode-cn.com/problems/plus-one/ 题目描述： 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数</description></item><item><title>Fabric中的账本数据存储</title><link>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%B8%AD%E7%9A%84%E8%B4%A6%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</link><pubDate>Sun, 18 Oct 2020 21:26:31 +0800</pubDate><guid>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%B8%AD%E7%9A%84%E8%B4%A6%E6%9C%AC%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</guid><description>Fabric账本数据的存储 Fabric账本数据存储模块提供了文件系统与键值型数据库用于存储账本数据，并被统一封装为Peer节点的账本对象（ k</description></item><item><title>Fabric中的读写集</title><link>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E9%9B%86/</link><pubDate>Sun, 18 Oct 2020 21:25:21 +0800</pubDate><guid>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E9%9B%86/</guid><description>Fabric中的读写集 在背书节点模拟执行交易期间，都会为每笔交易生成一个读写集。 读集(readset)包含了在模拟执行期间读取到的键的列表和</description></item><item><title>链码常见的API</title><link>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/%E9%93%BE%E7%A0%81%E5%B8%B8%E8%A7%81%E7%9A%84api/</link><pubDate>Sun, 18 Oct 2020 21:24:00 +0800</pubDate><guid>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/%E9%93%BE%E7%A0%81%E5%B8%B8%E8%A7%81%E7%9A%84api/</guid><description>levelDB和CouchDB都支持的API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 //键的写入 PutState(key string, value []byte) error //单个键的查询 GetState(key string) ([]byte, error) //键的范围查询(左</description></item><item><title>Fabric启用CouchDB作为状态数据库</title><link>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/fabric%E5%90%AF%E7%94%A8couchdb%E4%BD%9C%E4%B8%BA%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/</link><pubDate>Sun, 18 Oct 2020 21:22:31 +0800</pubDate><guid>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/fabric%E5%90%AF%E7%94%A8couchdb%E4%BD%9C%E4%B8%BA%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%E5%BA%93/</guid><description>Fabric中启用CouchDB 使用CouchDB的注意点 当chaincode的数据模型被构建为Json格式的时候，可以使用CouchDB，</description></item><item><title>CouchDB的基本语法</title><link>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E5%BA%93/couchdb%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</link><pubDate>Sun, 11 Oct 2020 21:16:52 +0800</pubDate><guid>http://localhost:1313/post/%E6%95%B0%E6%8D%AE%E5%BA%93/couchdb%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</guid><description>CouchDB基本语法 CouchDB的查询语法是json格式的，在其中可以通过特定的字段构建查询的逻辑，它的selector语法和Mongo</description></item><item><title>Fabric交易流程的详细分析</title><link>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%BA%A4%E6%98%93%E6%B5%81%E7%A8%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</link><pubDate>Sun, 11 Oct 2020 21:14:08 +0800</pubDate><guid>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/fabric%E4%BA%A4%E6%98%93%E6%B5%81%E7%A8%8B%E7%9A%84%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90/</guid><description>Fabric交易流程的详细分析 总体来讲，一个交易流程分为3个阶段：交易的模拟执行、交易打包生成区块、账本的更新 交易流程图： 第一阶段： 客户端创</description></item><item><title>背书节点和提交节点</title><link>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E8%83%8C%E4%B9%A6%E8%8A%82%E7%82%B9%E5%92%8C%E6%8F%90%E4%BA%A4%E8%8A%82%E7%82%B9/</link><pubDate>Sat, 10 Oct 2020 21:11:44 +0800</pubDate><guid>http://localhost:1313/post/fabric%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/%E8%83%8C%E4%B9%A6%E8%8A%82%E7%82%B9%E5%92%8C%E6%8F%90%E4%BA%A4%E8%8A%82%E7%82%B9/</guid><description>背书节点（Endorser peer） 主要是对请求服务的签名提案消息 启动链码容器 模拟执行链码 签名背书 客户端提交到账本的普通交易都需要经过背书节</description></item><item><title>动态添加组织</title><link>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E7%BB%84%E7%BB%87/</link><pubDate>Mon, 05 Oct 2020 09:03:17 +0800</pubDate><guid>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0%E7%BB%84%E7%BB%87/</guid><description>动态添加组织——CLI端 官方推荐将Cli容器与Org3cli容器的日志等级设置为DEBUG级别(但是我实际搭建也没有换，也没啥问题，可能是为</description></item><item><title>动态添加peer节点</title><link>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0peer%E8%8A%82%E7%82%B9/</link><pubDate>Mon, 05 Oct 2020 08:53:09 +0800</pubDate><guid>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/%E5%8A%A8%E6%80%81%E6%B7%BB%E5%8A%A0peer%E8%8A%82%E7%82%B9/</guid><description>大致流程 生成节点证书文件(依然是用过crypto-config.yaml文件) 启动新节点的docker容器 节点加入通道 节点安装链码 节点端执行</description></item><item><title>求逆序对(归排变种)</title><link>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E5%BD%92%E6%8E%92%E5%8F%98%E7%A7%8D/</link><pubDate>Sun, 30 Aug 2020 15:43:52 +0800</pubDate><guid>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%B1%82%E9%80%86%E5%BA%8F%E5%AF%B9%E5%BD%92%E6%8E%92%E5%8F%98%E7%A7%8D/</guid><description>逆序对，简单的说就是一个序列中，前面的数的数值比后面的数的数值大，那么这两个数就可以构成一个逆序对。 比如说 1 4 7 2 1 这个序列中，{4，2}{</description></item><item><title>快速选择(快排变种)--求第k个数</title><link>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E5%BF%AB%E6%8E%92%E5%8F%98%E7%A7%8D-%E6%B1%82%E7%AC%ACk%E4%B8%AA%E6%95%B0/</link><pubDate>Sun, 30 Aug 2020 14:38:56 +0800</pubDate><guid>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9%E5%BF%AB%E6%8E%92%E5%8F%98%E7%A7%8D-%E6%B1%82%E7%AC%ACk%E4%B8%AA%E6%95%B0/</guid><description>对于求一个序列的第k个数，首先想到的就是将序列进行排序，然后输出第k-1的下标即可，但是排序的算法平均时间复杂度最优的也是O(nlogn)，</description></item><item><title>排序(快排与归并)</title><link>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%BF%AB%E6%8E%92%E4%B8%8E%E5%BD%92%E5%B9%B6/</link><pubDate>Sun, 30 Aug 2020 10:15:11 +0800</pubDate><guid>http://localhost:1313/post/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E5%BF%AB%E6%8E%92%E4%B8%8E%E5%BD%92%E5%B9%B6/</guid><description>对于基础算法可以形成模板来进行记忆，主要在于算法的思想和熟练度！！！ 快速排序 基本思想 找分界点，随便找，一般是a[l]，a[r]，a[l+r&amp;</description></item><item><title>IPFS-js的简单使用</title><link>http://localhost:1313/post/ipfs/ipfs-js%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 29 Aug 2020 14:51:33 +0800</pubDate><guid>http://localhost:1313/post/ipfs/ipfs-js%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</guid><description/></item><item><title>fabric事件的监听使用</title><link>http://localhost:1313/post/fabricnodesdk/%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%91%E5%90%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 29 Aug 2020 14:34:22 +0800</pubDate><guid>http://localhost:1313/post/fabricnodesdk/%E4%BA%8B%E4%BB%B6%E7%9A%84%E7%9B%91%E5%90%AC%E4%BD%BF%E7%94%A8/</guid><description>使用fabric-network如何监听事件 本教程描述了使用fabricnetwork模块监听网络发出的事件的不同方法。 概览有三种事件类型可</description></item><item><title>交易invoke的使用</title><link>http://localhost:1313/post/fabricnodesdk/%E4%BA%A4%E6%98%93invoke%E7%9A%84%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 29 Aug 2020 14:25:47 +0800</pubDate><guid>http://localhost:1313/post/fabricnodesdk/%E4%BA%A4%E6%98%93invoke%E7%9A%84%E4%BD%BF%E7%94%A8/</guid><description>Fabric 1.4.x的新版高级API(Fabrci-NetWork模块)的使用 新版api引入了fabric-network模块，在原来的fabric</description></item><item><title>链码的访问控制(cid库)</title><link>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/cid%E9%93%BE%E7%A0%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%BA%93/</link><pubDate>Sat, 29 Aug 2020 13:27:15 +0800</pubDate><guid>http://localhost:1313/post/chaincode%E5%BC%80%E5%8F%91/cid%E9%93%BE%E7%A0%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%BA%93/</guid><description>Client Identity Chaincode Library（客户端标识链代码库） The client identity chaincode library enables you to write chaincode which makes access control decisions based on the identity of the client (i.e. the invoker of the chaincode). In particular, you may make access control decisions based on either or both of the following associated with the client: 客</description></item><item><title>ccp文件的设置</title><link>http://localhost:1313/post/fabricnodesdk/ccp-connection-file%E7%9A%84%E8%AE%BE%E7%BD%AE/</link><pubDate>Sat, 29 Aug 2020 13:03:02 +0800</pubDate><guid>http://localhost:1313/post/fabricnodesdk/ccp-connection-file%E7%9A%84%E8%AE%BE%E7%BD%AE/</guid><description>1.实验环境时，我们使用cli容器来进行链码的部署，实例化，以及进行简单的交易操作，但是在Fabric进行开发时，为了避免命令行的繁琐行，采</description></item><item><title>fabric1.4.x 网络部署的一些坑</title><link>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/fabric1.4.x%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</link><pubDate>Fri, 28 Aug 2020 17:18:13 +0800</pubDate><guid>http://localhost:1313/post/fabric%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2/fabric1.4.x%E7%BD%91%E7%BB%9C%E9%83%A8%E7%BD%B2%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9D%91/</guid><description>下面的搭建主要是基于fabric1.4.x出现错误 1.创建通道出现错误(注意如果出现重复创建通道建议去清理网络) 1 config update for existing channel did not pass initial checks: implicit policy evaluation</description></item><item><title>以太坊Ghost协议(5)</title><link>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8Aghost%E5%8D%8F%E8%AE%AE5/</link><pubDate>Mon, 24 Aug 2020 21:52:57 +0800</pubDate><guid>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8Aghost%E5%8D%8F%E8%AE%AE5/</guid><description>在以太坊中，出块的时间相对于BTC来说是非常短暂的，只有十几秒，但是出块时间越短，出现的短暂性分叉也就越多，这就会对部分节点，尤其是个体挖矿</description></item><item><title>以太坊交易树和收据树(4)</title><link>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%914/</link><pubDate>Mon, 24 Aug 2020 21:51:47 +0800</pubDate><guid>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%BA%A4%E6%98%93%E6%A0%91%E5%92%8C%E6%94%B6%E6%8D%AE%E6%A0%914/</guid><description>交易树与状态树 状态树 交易树 收据树 (把系统中的所有状态都记录进去，不管账户是否与当前区块中的相关交易关联的账户是什么关系) 区块产生时会生成(类</description></item><item><title>以太坊状态树(3)</title><link>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%913/</link><pubDate>Mon, 24 Aug 2020 21:50:16 +0800</pubDate><guid>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E6%A0%913/</guid><description>在Ethereum中，账户的状态是以键值对&amp;lt;key,value&amp;gt;的形式保存的，账户地址为key，账户的状态就是value，即&amp;l</description></item><item><title>以太坊账户(2)</title><link>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B72/</link><pubDate>Mon, 24 Aug 2020 21:46:36 +0800</pubDate><guid>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B72/</guid><description>背景 比特币中采用的是基于交易的账本，这种模式下，系统中并没有显式地记录账户中有多少钱 ，只能根据UTXO中的信息来推算。这种方式的隐私性较好，</description></item><item><title>以太坊概述(1)</title><link>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E8%BF%B01/</link><pubDate>Mon, 24 Aug 2020 21:40:38 +0800</pubDate><guid>http://localhost:1313/post/eth/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E6%A6%82%E8%BF%B01/</guid><description>以太坊被称为区块链2.0 创世人是V神，属于公有链的代表，和BTC的不同是，以太坊引入了智能合约，可以进行复杂的业务设计，不仅仅局限于解决pa</description></item><item><title>Git的基本使用</title><link>http://localhost:1313/post/git/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link><pubDate>Sun, 23 Aug 2020 20:57:28 +0800</pubDate><guid>http://localhost:1313/post/git/git%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid><description>Git的基本使用 新项目提交至github 1 2 3 4 5 6 7 8 9 10 git init //创建本地仓库 git add . //提交全部 git commit -m &amp;#34;提交时的注释，尽量写，方便</description></item><item><title>BTC—思考(11)</title><link>http://localhost:1313/post/btc/btc%E6%80%9D%E8%80%8311/</link><pubDate>Sun, 23 Aug 2020 20:20:45 +0800</pubDate><guid>http://localhost:1313/post/btc/btc%E6%80%9D%E8%80%8311/</guid><description>Hash 指针 比特币中的hash指针有两个作用：（1）区块之间的链接（2）交易时说明币的来源 1.指针保存的是本地内存的地址，只在本地这台计算机才有意</description></item><item><title>BTC—匿名性(10)</title><link>http://localhost:1313/post/btc/btc%E5%8C%BF%E5%90%8D%E6%80%A710/</link><pubDate>Sun, 23 Aug 2020 20:19:54 +0800</pubDate><guid>http://localhost:1313/post/btc/btc%E5%8C%BF%E5%90%8D%E6%80%A710/</guid><description>BTC的匿名性 在BTC中，账户的地址用的是公钥的hash，当然BTC也不是没有账户名的，可以使用化名（类似于网名） 有的人可能会为了匿名性使用</description></item><item><title>BTC—问答(9)</title><link>http://localhost:1313/post/btc/btc%E9%97%AE%E7%AD%949/</link><pubDate>Sun, 23 Aug 2020 20:19:32 +0800</pubDate><guid>http://localhost:1313/post/btc/btc%E9%97%AE%E7%AD%949/</guid><description>1.转账时，如果接收者不在线怎么办？ 转账时无需接受者在线，转账只是在账本上记账，无需实时在线，而且记账可以由网络的矿工进行 2.假设一个节点收</description></item><item><title>BTC—分叉(8)</title><link>http://localhost:1313/post/btc/btc%E5%88%86%E5%8F%898/</link><pubDate>Sun, 23 Aug 2020 20:10:23 +0800</pubDate><guid>http://localhost:1313/post/btc/btc%E5%88%86%E5%8F%898/</guid><description>BTC分叉(fork) 1 2 3 1.在挖矿时。如果两个peer几乎同时出了一个块，那就会出现一个暂时性的fork，这种fork成为state fo</description></item><item><title>BTC—脚本(7)</title><link>http://localhost:1313/post/btc/btc%E8%84%9A%E6%9C%AC7/</link><pubDate>Sun, 23 Aug 2020 20:09:50 +0800</pubDate><guid>http://localhost:1313/post/btc/btc%E8%84%9A%E6%9C%AC7/</guid><description>比特币的交易 交易结构 实际中为了安全起见脚本都是单独执行的！！！ 输入输出脚本的形式 （1）P2PK(最简单): 从上往下一次入栈，CHRECKSI</description></item><item><title>BTC—挖矿(6)</title><link>http://localhost:1313/post/btc/btc%E6%8C%96%E7%9F%BF6/</link><pubDate>Sun, 23 Aug 2020 20:09:06 +0800</pubDate><guid>http://localhost:1313/post/btc/btc%E6%8C%96%E7%9F%BF6/</guid><description>挖矿难度 调整挖矿的难度就是调整使得找到符合 H(block header) &amp;lt;= target的nounce的难度 比特币的hash算法是采用的是SHA-256算法，也就是ha</description></item><item><title>BTC—网络(5)</title><link>http://localhost:1313/post/btc/btc%E7%BD%91%E7%BB%9C5/</link><pubDate>Sun, 23 Aug 2020 20:08:40 +0800</pubDate><guid>http://localhost:1313/post/btc/btc%E7%BD%91%E7%BB%9C5/</guid><description>比特币网络的工作原理 比特币工作在应用层（application layer) : Bitcoin Blockchain 底层的网络层（network layer）: P2P Overlay Network 比特币网络的原则是：简</description></item><item><title>BTC—实现(4)</title><link>http://localhost:1313/post/btc/btc%E5%AE%9E%E7%8E%B04/</link><pubDate>Sun, 23 Aug 2020 20:07:43 +0800</pubDate><guid>http://localhost:1313/post/btc/btc%E5%AE%9E%E7%8E%B04/</guid><description>Transaction-based ledger(基于交易) 注：这种账本中每个账户上的余额是不直接显示的，要想知道一个账户上的余额，必须追溯交易的输入输出来推算出账户的余额 U</description></item><item><title>BTC—共识协议(3)</title><link>http://localhost:1313/post/btc/btc%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE3/</link><pubDate>Sun, 23 Aug 2020 20:07:04 +0800</pubDate><guid>http://localhost:1313/post/btc/btc%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE3/</guid><description>相对于传统的纸质货币，数字货币需要解决两个问题： 1.谁来发行货币，什么时候发行，发行多少（这是挖矿决定的） 2.如何验证交易的有效性，传统的纸</description></item><item><title>BTC—数据结构(2)</title><link>http://localhost:1313/post/btc/btc%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/</link><pubDate>Sun, 23 Aug 2020 20:06:04 +0800</pubDate><guid>http://localhost:1313/post/btc/btc%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%842/</guid><description>1.hash指针 普通的指针存储的是某个结构体在内存中的起始地址，但是hash地址除了存储这个地址，还存储结构体内容的hash，所以hash指</description></item><item><title>BTC 密码学原理(1)</title><link>http://localhost:1313/post/btc/btc-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%861/</link><pubDate>Sun, 23 Aug 2020 20:04:54 +0800</pubDate><guid>http://localhost:1313/post/btc/btc-%E5%AF%86%E7%A0%81%E5%AD%A6%E5%8E%9F%E7%90%861/</guid><description>比特币是一种加密货币——crypto-currency，但是其实加密的货币是不加密的，区块链上的数据都是公开的，包括账户的地址，转账的金额等</description></item></channel></rss>
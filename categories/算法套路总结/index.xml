<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法套路总结 on This is a blog written by VegeBun-csj to record the tech</title><link>http://localhost:1313/categories/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/</link><description>Recent content in 算法套路总结 on This is a blog written by VegeBun-csj to record the tech</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 26 Nov 2020 18:21:11 +0800</lastBuildDate><atom:link href="http://localhost:1313/categories/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/index.xml" rel="self" type="application/rss+xml"/><item><title>二分查找</title><link>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Thu, 26 Nov 2020 18:21:11 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description>二分法 对于二分法非常容易出问题的就是查找的边界问题 下面是两个常用的模板框架： 框架一 1 2 3 4 5 6 7 8 9 10 11 int l = 0; int r = nums.size() - 1; while (l &amp;lt;= r) { int mid =</description></item><item><title>BFS遍历模板</title><link>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/bfs%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</link><pubDate>Mon, 16 Nov 2020 14:38:28 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/bfs%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</guid><description>BFS模板 BFS又称宽度优先遍历，类似于树中的层次遍历，是一种从上至下，一层一层进行的遍历，通常采用队列来实现 基本框架 1 2 3 4 5 6 7 8 9 10 11</description></item><item><title>递归的写法以及注意点</title><link>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/%E9%80%92%E5%BD%92%E7%9A%84%E5%86%99%E6%B3%95/</link><pubDate>Sun, 15 Nov 2020 15:52:47 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/%E9%80%92%E5%BD%92%E7%9A%84%E5%86%99%E6%B3%95/</guid><description>所有的树的问题，都可以转化为递归来解决 递归的步骤：（产品经理法） 确定递归的边界 确定递归要干的事情 递归的返回值 递归的一个非常重要的点就是：不去</description></item></channel></rss>
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>树 on This is a blog written by VegeBun-csj to record the tech</title><link>http://localhost:1313/categories/%E6%A0%91/</link><description>Recent content in 树 on This is a blog written by VegeBun-csj to record the tech</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 19 Nov 2020 09:17:53 +0800</lastBuildDate><atom:link href="http://localhost:1313/categories/%E6%A0%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode297 二叉树的序列化和反序列化</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link><pubDate>Thu, 19 Nov 2020 09:17:53 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid><description>题目描述 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一</description></item><item><title>Leetcode114 二叉树展开为链表</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</link><pubDate>Tue, 17 Nov 2020 21:53:48 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode114-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8/</guid><description>题目描述 给定一个二叉树，原地将它展开为一个单链表。 例如，给定二叉树 题目链接 https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/ 思路 二叉树的题目都可以使用递归来做，对于递归，我们并不需要深入到</description></item><item><title>Leetcode106 从中序和后序遍历构造二叉树</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Tue, 17 Nov 2020 21:48:38 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode106-%E4%BB%8E%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>题目描述 根据一棵树的中序遍历与后序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素 例如，给出 中序遍历 inorder = [9,3,15,20,7] 后序遍历 postorder = [9,15,7,20,3] 题目链接 https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal 思路 思路</description></item><item><title>Leetcode105 从前序和中序遍历构造二叉树</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Tue, 17 Nov 2020 21:48:20 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode105-%E4%BB%8E%E5%89%8D%E5%BA%8F%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>题目描述 根据一棵树的前序遍历与中序遍历构造二叉树。 注意: 你可以假设树中没有重复的元素 例如，给出 前序遍历 preorder = [3,9,20,15,7] 中序遍历 inorder = [9,3,15,20,7] 题目链接 https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal 思路 首先</description></item><item><title>Leetcode654 最大二叉树</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</link><pubDate>Tue, 17 Nov 2020 21:32:45 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode654-%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91/</guid><description>题目描述 给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下： 二叉树的根是数组中的最大元素。 左子树是通过数组中最大值左边部分</description></item><item><title>BFS遍历模板</title><link>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/bfs%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</link><pubDate>Mon, 16 Nov 2020 14:38:28 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E7%AE%97%E6%B3%95%E5%A5%97%E8%B7%AF%E6%80%BB%E7%BB%93/bfs%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</guid><description>BFS模板 BFS又称宽度优先遍历，类似于树中的层次遍历，是一种从上至下，一层一层进行的遍历，通常采用队列来实现 基本框架 1 2 3 4 5 6 7 8 9 10 11</description></item><item><title>Leetcode513 找树左下角的值</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode-513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</link><pubDate>Mon, 16 Nov 2020 11:42:28 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode-513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</guid><description>题目描述 给定一个二叉树，在树的最后一行找到最左边的值。（这里说的是最后一层的最左边的值，并不是直观上的最左下角的节点哦） 题目链接 https://leetcode-cn.com/problems/find-bottom-left-tree-value/ 思路一(B</description></item><item><title>Leetcode129 求根到叶子节点数字之和</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</link><pubDate>Sun, 15 Nov 2020 15:30:47 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</guid><description>题目描述 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&amp;gt;2-&amp;gt;3 代表数字 123。 计</description></item><item><title>二叉树的遍历系列_4种</title><link>http://localhost:1313/post/leetcode/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%B3%BB%E5%88%97_4%E7%A7%8D/</link><pubDate>Sat, 14 Nov 2020 21:00:34 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E9%AB%98%E9%A2%91%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%B3%BB%E5%88%97_4%E7%A7%8D/</guid><description>题目描述 对二叉树进行前中后层序遍历，分别递归与非递归遍历 题目链接 leetcode 144 https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ leetcode94 https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ leetcode145 https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ 102 https://leetcode-cn.com/problems/binary-tree-level-order-traversal/ 思路 递归遍历 三种遍历的唯一区别就是对根节点的操作和递归操作</description></item><item><title>Leetcode226 翻转二叉树_二叉树的镜像</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link><pubDate>Sat, 14 Nov 2020 20:58:21 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid><description>题目描述 翻转一棵二叉树。 题目链接 https://leetcode-cn.com/problems/invert-binary-tree/ 思路 首先可以看到，翻转后的二叉树就是： 以根节点为基础交换两棵左右子树 交换完成后再对左右子树进行同样的操作（</description></item><item><title>Leetcode100 相同的树</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link><pubDate>Sat, 14 Nov 2020 16:06:45 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid><description>题目描述 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 题目链接 https://leetcode-cn.com/problems/same-tree/ 思路 题目</description></item><item><title>Leetcode104 二叉树的最大深度</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link><pubDate>Fri, 13 Nov 2020 14:58:27 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid><description>题目描述 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给</description></item></channel></rss>
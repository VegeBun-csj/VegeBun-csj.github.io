<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>递归 on This is a blog written by VegeBun-csj to record the tech</title><link>http://localhost:1313/categories/%E9%80%92%E5%BD%92/</link><description>Recent content in 递归 on This is a blog written by VegeBun-csj to record the tech</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 16 Nov 2020 11:42:28 +0800</lastBuildDate><atom:link href="http://localhost:1313/categories/%E9%80%92%E5%BD%92/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode513 找树左下角的值</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode-513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</link><pubDate>Mon, 16 Nov 2020 11:42:28 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode-513%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC/</guid><description>题目描述 给定一个二叉树，在树的最后一行找到最左边的值。 题目链接 https://leetcode-cn.com/problems/find-bottom-left-tree-value/ 思路一(BFS) BFS：通常我们写的BFS是从上往下，从左往右遍历，这样遍历</description></item><item><title>递归的写法以及注意点</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/%E9%80%92%E5%BD%92%E7%9A%84%E5%86%99%E6%B3%95/</link><pubDate>Sun, 15 Nov 2020 15:52:47 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/%E9%80%92%E5%BD%92%E7%9A%84%E5%86%99%E6%B3%95/</guid><description>所有的树的问题，都可以转化为递归来解决 递归的步骤：（产品经理法） 确定递归的边界 确定递归要干的事情 递归的返回值 递归的一个非常重要的点就是：不去</description></item><item><title>Leetcode129 求根到叶子节点数字之和</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</link><pubDate>Sun, 15 Nov 2020 15:30:47 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode129-%E6%B1%82%E6%A0%B9%E5%88%B0%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C/</guid><description>题目描述 给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。 例如，从根到叶子节点路径 1-&amp;gt;2-&amp;gt;3 代表数字 123。 计</description></item><item><title>Leetcode226 二叉树的遍历_3种</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86_3%E7%A7%8D/</link><pubDate>Sat, 14 Nov 2020 21:00:34 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86_3%E7%A7%8D/</guid><description>题目描述 对二叉树进行前中后序遍历 题目链接 https://leetcode-cn.com/problems/binary-tree-preorder-traversal/ https://leetcode-cn.com/problems/binary-tree-inorder-traversal/ https://leetcode-cn.com/problems/binary-tree-postorder-traversal/ 思路 递归遍历，三种遍历的唯一区别就是对根节点的操作和递归操作左右子树的顺序不一样， 代码 前序遍历</description></item><item><title>Leetcode226 翻转二叉树_二叉树的镜像</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</link><pubDate>Sat, 14 Nov 2020 20:58:21 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91_%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</guid><description>题目描述 翻转一棵二叉树。 题目链接 https://leetcode-cn.com/problems/invert-binary-tree/ 思路 首先可以看到，翻转后的二叉树就是： 以根节点为基础交换两棵左右子树 交换完成后再对左右子树进行同样的操作（</description></item><item><title>Leetcode100 相同的树</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link><pubDate>Sat, 14 Nov 2020 16:06:45 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode100-%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid><description>题目描述 给定两个二叉树，编写一个函数来检验它们是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 题目链接 https://leetcode-cn.com/problems/same-tree/ 思路 题目</description></item><item><title>Leetcode104 二叉树的最大深度</title><link>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link><pubDate>Fri, 13 Nov 2020 14:58:27 +0800</pubDate><guid>http://localhost:1313/post/leetcode/%E6%A0%91/leetcode104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid><description>题目描述 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给</description></item></channel></rss>